/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:10:27
 */
import { __awaiter, __extends, __generator } from "tslib";
import { noop } from 'monofile-utilities/lib/consts';
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { debuglog } from 'util';
import { HTTP_INTERNAL_SERVER_ERROR, HTTP_NOT_FOUND, isIncomeMessage, } from './messages';
import { STMPContext } from './STMPContext';
import { STMPEncoding } from './STMPEncoding';
import { newError, STMPSource, } from './types';
import { normalizeSendOptions } from './utils';
// @ts-ignore
var debug = debuglog('stmp:STMPServer');
var STMPServer = /** @class */ (function (_super) {
    __extends(STMPServer, _super);
    function STMPServer(adaptors, authenticate, options) {
        if (authenticate === void 0) { authenticate = noop; }
        if (options === void 0) { options = {}; }
        var _a;
        var _this = _super.call(this) || this;
        _this.authenticate = authenticate;
        _this.connections = new Set();
        _this.groups = new Map();
        _this.handlers = new Map();
        _this.defaultContentType = (_a = options.defaultContentType, (_a !== null && _a !== void 0 ? _a : 'application/json'));
        adaptors.forEach(function (adaptor) { return adaptor.attach(_this); });
        return _this;
    }
    /** @internal */
    STMPServer.prototype.processMessage = function (connection, message) {
        return __awaiter(this, void 0, void 0, function () {
            var handler, ctx, codec, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.emit('message', connection, message);
                        if (!isIncomeMessage(message)) {
                            return [2 /*return*/];
                        }
                        handler = this.handlers.get(message.action);
                        ctx = new STMPContext(message, connection);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, this.emitSerial('beforeHandle', ctx)];
                    case 2:
                        _a.sent();
                        if (ctx.isFinished()) {
                            this.emit('afterHandle', ctx);
                            return [2 /*return*/];
                        }
                        if (!handler) {
                            ctx.text('Not Found', HTTP_NOT_FOUND);
                            this.emit('afterHandle', ctx);
                            return [2 /*return*/];
                        }
                        if (ctx.input === void 0 && ctx.incoming.payload) {
                            codec = STMPEncoding.get(ctx.get('content-type'));
                            if (codec) {
                                ctx.input = codec.decodeReq(ctx.incoming.payload, ctx);
                            }
                        }
                        return [4 /*yield*/, handler[1](ctx)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _a.sent();
                        if (!ctx.isFinished()) {
                            ctx.text('Internal Server Error', HTTP_INTERNAL_SERVER_ERROR);
                        }
                        debug('handle %s, internal server error: %s.', message.action, error_1);
                        this.emit('error', newError(STMPSource.HANDLE_REQUEST, { error: error_1, ctx: ctx }));
                        return [3 /*break*/, 5];
                    case 5: return [4 /*yield*/, this.emitSerial('afterHandle', ctx)];
                    case 6:
                        _a.sent();
                        if (!ctx.isFinished()) {
                            ctx.text('Not Found', HTTP_NOT_FOUND);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    STMPServer.prototype.use = function (action, handler, options) {
        this.handlers.set(action, [options, handler]);
    };
    STMPServer.prototype.broadcast = function (a, b, c, d) {
        var options = typeof a === 'string'
            ? {
                action: a,
                data: b,
                headers: c,
            }
            : a;
        var filter = typeof a === 'string' ? d : b;
        if (filter) {
            this.connections.forEach(function (c) { return filter(c) && c.push(options); });
        }
        else {
            this.connections.forEach(function (c) { return c.push(options); });
        }
    };
    STMPServer.prototype.pushGroup = function (groupId, a, b, c, d) {
        var _a, _b;
        var options = normalizeSendOptions(a, b, c);
        var filter = typeof a === 'string' ? d : b;
        if (filter) {
            (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach(function (c) { return filter(c) && c.push(options); });
        }
        else {
            (_b = this.groups.get(groupId)) === null || _b === void 0 ? void 0 : _b.forEach(function (c) { return c.push(options); });
        }
    };
    STMPServer.prototype.closeGroup = function (groupId, status, message) {
        var _a;
        (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach(function (conn) { return conn.close(status, message); });
    };
    STMPServer.prototype.fireGroup = function (groupId) {
        var _a;
        (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach(function (conn) { return conn.leaveGroup(groupId); });
    };
    return STMPServer;
}(EventDispatcher));
export { STMPServer };
//# sourceMappingURL=STMPServer.js.map