/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 17:51:35
 */
import { __extends } from "tslib";
import { debuglog } from 'util';
import { Headers, HTTP_BAD_REQUEST, HTTP_OK, HTTP_REQUEST_TIMEOUT, WS_PROTOCOL_ERROR, } from './messages';
import { parseBinary, parseHeaders, stringifyBinary } from './protocol';
import { STMPConnection } from './STMPConnection';
import { StreamConsumer } from './StreamConsumer';
import { b16, createPrefixedBuffer } from './utils';
var debug = debuglog('stmp:TCPConnection');
var HANDSHAKE_TIMEOUT = createPrefixedBuffer(b16(HTTP_REQUEST_TIMEOUT));
var HANDSHAKE_BAD_REQUEST = createPrefixedBuffer(b16(HTTP_BAD_REQUEST));
var TCPConnection = /** @class */ (function (_super) {
    __extends(TCPConnection, _super);
    function TCPConnection(server, socket) {
        var _this = _super.call(this, server, socket) || this;
        _this.handleHandshakeData = function (data) {
            var header = _this.consumer.consumeFrame(data);
            if (!header) {
                return;
            }
            debug('handshake frame: %s.', header);
            clearTimeout(_this.handshakeTimer);
            _this.handshakeTimer = undefined;
            if (header.length < 1) {
                _this.socket.end(HANDSHAKE_BAD_REQUEST);
                return;
            }
            var handshake = header.toString();
            var newLine = handshake.indexOf('\n');
            var url = newLine < 0 ? handshake : handshake.substr(0, newLine);
            var headers = newLine < 0 ? Headers() : parseHeaders(handshake.substr(newLine + 1));
            _this.socket.removeListener('data', _this.handleHandshakeData);
            _this.init(url, headers);
            _this.authenticate().then(function () {
                if (_this.handshakeStatus === HTTP_OK) {
                    _this.socket.on('data', _this.handleMessageData);
                }
            });
        };
        _this.handleMessageData = function (data) {
            var frame = _this.consumer.consumeFrame(data);
            if (!frame) {
                return;
            }
            var message = parseBinary(frame);
            debug('receive message frame: %s as %s to %O.', data, frame, message);
            if (!message) {
                _this.close(WS_PROTOCOL_ERROR);
                return;
            }
            message = _this.consumer.mergeMessage(message);
            if (message === null) {
                return;
            }
            _this.processMessage(message);
        };
        _this.handleHandshakeTimeout = function () {
            _this.socket.removeAllListeners('data');
            _this.socket.end(HANDSHAKE_TIMEOUT);
        };
        _this.consumer = new StreamConsumer();
        return _this;
    }
    TCPConnection.prototype.prepare = function (handshakeTimeout) {
        this.handshakeTimer = setTimeout(this.handleHandshakeTimeout, handshakeTimeout);
        this.socket.on('data', this.handleHandshakeData);
    };
    TCPConnection.prototype.send = function (message) {
        var buf = stringifyBinary(message);
        this.socket.write(createPrefixedBuffer(buf));
    };
    TCPConnection.prototype.sendHandshake = function (status, message) {
        this.socket.write(createPrefixedBuffer(b16(status), message));
    };
    TCPConnection.prototype.terminate = function () {
        this.socket.removeAllListeners();
        this.socket.end();
    };
    return TCPConnection;
}(STMPConnection));
export { TCPConnection };
//# sourceMappingURL=TCPConnection.js.map