"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 18:35:29
 */
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("./messages");
const STMPEncoding_1 = require("./STMPEncoding");
const varint_1 = require("./varint");
function mapMap(input) {
    const backward = {};
    for (const key in input) {
        if (input.hasOwnProperty(key)) {
            backward[input[key]] = key;
        }
    }
    return { forward: input, backward: backward };
}
exports.mapMap = mapMap;
function b8(value, buf = Buffer.allocUnsafe(1)) {
    buf.writeUInt8(value, 0);
    return buf;
}
exports.b8 = b8;
function b16(value, buf = Buffer.allocUnsafe(2)) {
    buf.writeUInt16BE(value, 0);
    return buf;
}
exports.b16 = b16;
function b32(value, buf = Buffer.allocUnsafe(4)) {
    buf.writeUInt32BE(value, 0);
    return buf;
}
exports.b32 = b32;
function createBuffer(...chunks) {
    return Buffer.concat(chunks.map((item) => {
        if (typeof item === 'string') {
            return Buffer.from(item);
        }
        return item;
    }));
}
exports.createBuffer = createBuffer;
function createPrefixedBuffer(...chunks) {
    const content = createBuffer(...chunks);
    return Buffer.concat([varint_1.writeVarint(content.length), content]);
}
exports.createPrefixedBuffer = createPrefixedBuffer;
/** @internal */
function normalizeSendOptions(a, b, c, thisHeaders) {
    var _a, _b, _c;
    const options = typeof a === 'string'
        ? {
            action: a,
            data: b,
            headers: c,
        }
        : a;
    options.headers = options.headers || messages_1.Headers();
    options.payloadRecord = options.payloadRecord || messages_1.Headers();
    if (arguments.length < 4) {
        return options;
    }
    const headers = messages_1.Headers();
    if (options.headers && options.headers !== thisHeaders) {
        for (const k in options.headers) {
            const key = k.toLowerCase();
            if (thisHeaders[key] !== options.headers[k]) {
                headers[k] = options.headers[k];
            }
        }
    }
    const contentType = (_c = (_b = (_a = options.contentType, (_a !== null && _a !== void 0 ? _a : options.headers['content-type'])), (_b !== null && _b !== void 0 ? _b : thisHeaders['content-type'])), (_c !== null && _c !== void 0 ? _c : 'application/json'));
    if (!messages_1.isPayload(options.payloadRecord[contentType], false)) {
        if (messages_1.isPayload(options.data)) {
            options.payloadRecord[contentType] = options.data;
        }
        else {
            const codec = STMPEncoding_1.STMPEncoding.get(contentType);
            if (!codec) {
                throw new Error(`cannot encode media "${contentType}"`);
            }
            options.payloadRecord[contentType] = codec.encodeReq(options.data, options);
        }
    }
    const payload = options.payloadRecord[contentType];
    return Object.setPrototypeOf({ headers, payload }, options);
}
exports.normalizeSendOptions = normalizeSendOptions;
function encodeString(str) {
    return str
        .replace(/%/g, '%25')
        .replace(/:/g, '%3A')
        .replace(/\n/g, '%0A');
}
exports.encodeString = encodeString;
function decodeString(str) {
    return str.replace(/%([0-9a-fA-F]{2})/g, ($0, $1) => {
        switch ($1) {
            case '25':
                return '%';
            case '3A':
            case '3a':
                return ':';
            case '0A':
            case '0a':
                return '\n';
            default:
                return $0;
        }
    });
}
exports.decodeString = decodeString;
/** @internal */
function normalizeHeaders(headers) {
    Object.setPrototypeOf(headers, null);
    for (const k in headers) {
        const key = k.toLowerCase();
        if (k !== key) {
            headers[key] = headers[k];
            delete headers[k];
        }
    }
    return headers;
}
exports.normalizeHeaders = normalizeHeaders;
//# sourceMappingURL=utils.js.map