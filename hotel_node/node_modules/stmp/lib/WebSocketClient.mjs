/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 */
import { __extends } from "tslib";
import { appendQuery } from 'monofile-utilities/lib/query-string';
import { debuglog } from 'util';
import { Headers, isCloseMessage, WS_NORMAL_CLOSURE, WS_PROTOCOL_ERROR, WS_USER_MIN, } from './messages';
import { parseText, stringifyText } from './protocol';
import { STMPClient } from './STMPClient';
import { newError, STMPSource } from './types';
var debug = debuglog('stmp:WebSocketClient');
var WebSocketClient = /** @class */ (function (_super) {
    __extends(WebSocketClient, _super);
    function WebSocketClient(url, headers, options) {
        if (headers === void 0) { headers = Headers(); }
        var _this = _super.call(this, headers, options) || this;
        _this.url = url;
        return _this;
    }
    WebSocketClient.prototype.terminate = function () {
        this.ws.onmessage = this.ws.onclose = this.ws.onerror = null;
    };
    WebSocketClient.prototype.connect = function (remainCount, previousStatus, previousMessage) {
        var _this = this;
        if (remainCount === void 0) { remainCount = this.maxRetryCount; }
        if (previousStatus === void 0) { previousStatus = null; }
        if (previousMessage === void 0) { previousMessage = null; }
        if (this.readyState !== 'closed') {
            return Promise.reject(new Error("cannot connect with readyState: " + this.readyState));
        }
        this.readyState = 'connecting';
        this.emit('connecting', {
            remainCount: remainCount,
            retryCount: this.maxRetryCount - remainCount,
            previousStatus: previousStatus,
            previousMessage: previousMessage,
        });
        var timeoutHandler;
        return new Promise(function (resolve, reject) {
            var ws = (_this.ws = new WebSocketClient.WebSocket(appendQuery(_this.url, {
                __stmp_headers__: _this.headers,
            })));
            timeoutHandler = setTimeout(function () { return reject(new Error('connect timeout')); }, _this.handshakeTimeout);
            ws.onmessage = function (ev) {
                if (typeof ev.data === 'string') {
                    var newLine = ev.data.indexOf('\n');
                    var status_1 = +ev.data.substr(0, newLine > -1 ? newLine : void 0);
                    var message = newLine > -1 ? ev.data.substr(newLine + 1) : '';
                    debug('handshake response [%s]: %s.', status_1, message);
                    if (status_1 > 299) {
                        reject({ status: status_1, message: message });
                    }
                    else {
                        clearTimeout(timeoutHandler);
                        _this.readyState = 'connected';
                        _this.emit('connected', { status: status_1, message: message });
                        _this.ws.onmessage = function (ev) {
                            var message = parseText(ev.data);
                            debug('received raw message: %s: %O.', ev.data, message);
                            if (!message) {
                                _this.close(WS_PROTOCOL_ERROR, 'Invalid Message');
                            }
                            else {
                                _this.processMessage(message);
                            }
                        };
                        _this.ws.onerror = function (event) {
                            _this.emit('error', newError(STMPSource.TRANSPORT_ERROR, { event: event }));
                        };
                        _this.ws.onclose = function (ev) {
                            _this.close(ev.code, ev.reason);
                        };
                        resolve([status_1, message]);
                    }
                }
                else {
                    reject(ev);
                }
            };
            ws.onclose = ws.onerror = reject;
        }).catch(function (reason) {
            var _a, _b;
            clearTimeout(timeoutHandler);
            _this.readyState = 'closed';
            _this.ws.onmessage = _this.ws.onerror = _this.ws.onclose = null;
            if (remainCount > 0) {
                return _this.connect(remainCount - 1, (_a = reason) === null || _a === void 0 ? void 0 : _a.status, (_b = reason) === null || _b === void 0 ? void 0 : _b.message);
            }
            else {
                return Promise.reject(reason);
            }
        });
    };
    WebSocketClient.prototype.send = function (message) {
        if (isCloseMessage(message)) {
            if (this.ws.readyState === this.ws.OPEN) {
                this.ws.close(message.status >= WS_USER_MIN ? message.status : WS_NORMAL_CLOSURE, message.message);
            }
        }
        else {
            this.ws.send(stringifyText(message));
        }
    };
    WebSocketClient.WebSocket = WebSocket;
    return WebSocketClient;
}(STMPClient));
export { WebSocketClient };
//# sourceMappingURL=WebSocketClient.js.map