"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 *
 * TODO
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const array_1 = require("monofile-utilities/lib/array");
const consts_1 = require("monofile-utilities/lib/consts");
const EventDispatcher_1 = require("monofile-utilities/lib/EventDispatcher");
const util_1 = require("util");
const messages_1 = require("./messages");
const STMPContext_1 = require("./STMPContext");
const STMPEncoding_1 = require("./STMPEncoding");
const STMPResponse_1 = require("./STMPResponse");
const types_1 = require("./types");
const utils_1 = require("./utils");
const debug = util_1.debuglog('stmp:STMPClient');
class STMPClient extends EventDispatcher_1.EventDispatcher {
    constructor(headers, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        super();
        this.headers = utils_1.normalizeHeaders(headers);
        headers['content-type'] = headers['content-type'] || 'application/json';
        this.requestTimeout = (_a = options.requestTimeout, (_a !== null && _a !== void 0 ? _a : consts_1.T_MINUTE));
        this.pingInterval = (_b = options.pingInterval, (_b !== null && _b !== void 0 ? _b : consts_1.T_MINUTE));
        this.pingTimeout = (_c = options.pingTimeout, (_c !== null && _c !== void 0 ? _c : 10 * consts_1.T_SECOND));
        this.autoPing = (_d = options.autoPing, (_d !== null && _d !== void 0 ? _d : true));
        this.handshakeTimeout = (_e = options.handshakeTimeout, (_e !== null && _e !== void 0 ? _e : consts_1.T_MINUTE));
        this.maxRetryCount = (_f = options.maxRetryCount, (_f !== null && _f !== void 0 ? _f : 7));
        this.autoRetry = (_g = options.autoRetry, (_g !== null && _g !== void 0 ? _g : true));
        this.nextId = 0;
        this.requests = Object.create(null);
        this.handlers = Object.create(null);
        this.readyState = 'closed';
    }
    startPing() {
        // TODO: ping
    }
    messageId() {
        return (this.nextId = (this.nextId + 1) & 0xffff);
    }
    push(a, b, c) {
        const options = utils_1.normalizeSendOptions(a, b, c, this.headers);
        this.send(messages_1.createPushMessage(this.messageId(), options.action, options.payload, options.headers));
    }
    fetch(a, b, c) {
        const req = utils_1.normalizeSendOptions(a, b, c, this.headers);
        const message = messages_1.createRequestMessage(this.messageId(), req.action, req.payload, req.headers);
        return new Promise((resolve, reject) => {
            this.send(message);
            let timeoutHandler = setTimeout(() => {
                delete this.requests[message.messageId];
                reject(types_1.newError(types_1.STMPSource.REQUEST_TIMEOUT, { req }));
            }, this.requestTimeout);
            this.requests[message.messageId] = (res, error) => {
                clearTimeout(timeoutHandler);
                delete this.requests[message.messageId];
                if (!res) {
                    reject(error);
                    return;
                }
                const response = new STMPResponse_1.STMPResponse(this, req, res);
                this.emit('response', response);
                if (res.payload) {
                    const codec = STMPEncoding_1.STMPEncoding.get(response.get('content-type'));
                    if (codec) {
                        try {
                            response.data = codec.decodeRes(res.payload, response);
                        }
                        catch (e) {
                            reject(types_1.newError(types_1.STMPSource.PARSE_RESPONSE_ERROR, {
                                req,
                                res,
                                error: e,
                            }));
                            return;
                        }
                    }
                }
                if (res.status > 299) {
                    reject(types_1.newError(types_1.STMPSource.STATUS_NOT_OK, { req, res }));
                }
                else {
                    resolve(response);
                }
            };
        });
    }
    close(status, message) {
        if (this.readyState !== 'connected') {
            return;
        }
        for (const k in this.requests) {
            this.requests[k](null, types_1.newError(types_1.STMPSource.CONNECTION_CLOSED, {
                close: messages_1.createCloseMessage(status, message),
            }));
        }
        this.readyState = 'closed';
        const close = messages_1.createCloseMessage(status, message);
        this.send(close);
        this.terminate();
        this.emit('closed', close);
    }
    processMessage(message) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            debug('receive message %O.', message);
            this.emit('message', message);
            if (messages_1.isCloseMessage(message)) {
                this.close(message.status, message.message);
            }
            else if (messages_1.isPingMessage(message)) {
                // TODO: validate ping status
            }
            else if (messages_1.isResponseMessage(message)) {
                (_b = (_a = this.requests)[message.messageId]) === null || _b === void 0 ? void 0 : _b.call(_a, message, null);
            }
            else if (messages_1.isExchangeMessage(message)) {
                const ctx = new STMPContext_1.STMPContext(message, this);
                const handlers = this.handlers[message.action];
                if (!handlers) {
                    ctx.output('Not Found', messages_1.HTTP_NOT_FOUND);
                }
                this.emit('beforeHandle', ctx);
                if (handlers) {
                    try {
                        const codec = STMPEncoding_1.STMPEncoding.get(ctx.get('content-type'));
                        ctx.action = handlers[0];
                        if (codec && ctx.incoming.payload) {
                            codec.decodeReq(ctx.incoming.payload, ctx);
                        }
                        for (const h of handlers[1]) {
                            yield h(ctx);
                        }
                    }
                    catch (error) {
                        ctx.output('Internal Server Error', messages_1.HTTP_INTERNAL_SERVER_ERROR);
                        this.emit('error', types_1.newError(types_1.STMPSource.HANDLE_REQUEST, { error, ctx }));
                    }
                }
                this.emit('afterHandle', ctx);
            }
        });
    }
    use(action, handler, options) {
        const handlers = this.handlers[action];
        if (handlers) {
            handlers[0] = options;
            handlers[1].push(handler);
        }
        else {
            this.handlers[action] = [options, [handler]];
        }
    }
    drop(action, handler) {
        const handlers = this.handlers[action];
        if (handlers) {
            array_1.splice(handlers[1], handler);
            if (handlers[1].length === 0) {
                delete this.handlers[action];
            }
        }
    }
}
exports.STMPClient = STMPClient;
//# sourceMappingURL=STMPClient.js.map