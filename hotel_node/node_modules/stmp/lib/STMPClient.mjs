/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 *
 * TODO
 */
import { __awaiter, __extends, __generator, __values } from "tslib";
import { splice } from 'monofile-utilities/lib/array';
import { T_MINUTE, T_SECOND } from 'monofile-utilities/lib/consts';
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { debuglog } from 'util';
import { createCloseMessage, createPushMessage, createRequestMessage, HTTP_INTERNAL_SERVER_ERROR, HTTP_NOT_FOUND, isCloseMessage, isExchangeMessage, isPingMessage, isResponseMessage, } from './messages';
import { STMPContext } from './STMPContext';
import { STMPEncoding } from './STMPEncoding';
import { STMPResponse } from './STMPResponse';
import { newError, STMPSource, } from './types';
import { normalizeHeaders, normalizeSendOptions } from './utils';
var debug = debuglog('stmp:STMPClient');
var STMPClient = /** @class */ (function (_super) {
    __extends(STMPClient, _super);
    function STMPClient(headers, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e, _f, _g;
        var _this = _super.call(this) || this;
        _this.headers = normalizeHeaders(headers);
        headers['content-type'] = headers['content-type'] || 'application/json';
        _this.requestTimeout = (_a = options.requestTimeout, (_a !== null && _a !== void 0 ? _a : T_MINUTE));
        _this.pingInterval = (_b = options.pingInterval, (_b !== null && _b !== void 0 ? _b : T_MINUTE));
        _this.pingTimeout = (_c = options.pingTimeout, (_c !== null && _c !== void 0 ? _c : 10 * T_SECOND));
        _this.autoPing = (_d = options.autoPing, (_d !== null && _d !== void 0 ? _d : true));
        _this.handshakeTimeout = (_e = options.handshakeTimeout, (_e !== null && _e !== void 0 ? _e : T_MINUTE));
        _this.maxRetryCount = (_f = options.maxRetryCount, (_f !== null && _f !== void 0 ? _f : 7));
        _this.autoRetry = (_g = options.autoRetry, (_g !== null && _g !== void 0 ? _g : true));
        _this.nextId = 0;
        _this.requests = Object.create(null);
        _this.handlers = Object.create(null);
        _this.readyState = 'closed';
        return _this;
    }
    STMPClient.prototype.startPing = function () {
        // TODO: ping
    };
    STMPClient.prototype.messageId = function () {
        return (this.nextId = (this.nextId + 1) & 0xffff);
    };
    STMPClient.prototype.push = function (a, b, c) {
        var options = normalizeSendOptions(a, b, c, this.headers);
        this.send(createPushMessage(this.messageId(), options.action, options.payload, options.headers));
    };
    STMPClient.prototype.fetch = function (a, b, c) {
        var _this = this;
        var req = normalizeSendOptions(a, b, c, this.headers);
        var message = createRequestMessage(this.messageId(), req.action, req.payload, req.headers);
        return new Promise(function (resolve, reject) {
            _this.send(message);
            var timeoutHandler = setTimeout(function () {
                delete _this.requests[message.messageId];
                reject(newError(STMPSource.REQUEST_TIMEOUT, { req: req }));
            }, _this.requestTimeout);
            _this.requests[message.messageId] = function (res, error) {
                clearTimeout(timeoutHandler);
                delete _this.requests[message.messageId];
                if (!res) {
                    reject(error);
                    return;
                }
                var response = new STMPResponse(_this, req, res);
                _this.emit('response', response);
                if (res.payload) {
                    var codec = STMPEncoding.get(response.get('content-type'));
                    if (codec) {
                        try {
                            response.data = codec.decodeRes(res.payload, response);
                        }
                        catch (e) {
                            reject(newError(STMPSource.PARSE_RESPONSE_ERROR, {
                                req: req,
                                res: res,
                                error: e,
                            }));
                            return;
                        }
                    }
                }
                if (res.status > 299) {
                    reject(newError(STMPSource.STATUS_NOT_OK, { req: req, res: res }));
                }
                else {
                    resolve(response);
                }
            };
        });
    };
    STMPClient.prototype.close = function (status, message) {
        if (this.readyState !== 'connected') {
            return;
        }
        for (var k in this.requests) {
            this.requests[k](null, newError(STMPSource.CONNECTION_CLOSED, {
                close: createCloseMessage(status, message),
            }));
        }
        this.readyState = 'closed';
        var close = createCloseMessage(status, message);
        this.send(close);
        this.terminate();
        this.emit('closed', close);
    };
    STMPClient.prototype.processMessage = function (message) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var ctx, handlers, codec, _c, _d, h, e_1_1, error_1;
            var e_1, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        debug('receive message %O.', message);
                        this.emit('message', message);
                        if (!isCloseMessage(message)) return [3 /*break*/, 1];
                        this.close(message.status, message.message);
                        return [3 /*break*/, 15];
                    case 1:
                        if (!isPingMessage(message)) return [3 /*break*/, 2];
                        return [3 /*break*/, 15];
                    case 2:
                        if (!isResponseMessage(message)) return [3 /*break*/, 3];
                        (_b = (_a = this.requests)[message.messageId]) === null || _b === void 0 ? void 0 : _b.call(_a, message, null);
                        return [3 /*break*/, 15];
                    case 3:
                        if (!isExchangeMessage(message)) return [3 /*break*/, 15];
                        ctx = new STMPContext(message, this);
                        handlers = this.handlers[message.action];
                        if (!handlers) {
                            ctx.output('Not Found', HTTP_NOT_FOUND);
                        }
                        this.emit('beforeHandle', ctx);
                        if (!handlers) return [3 /*break*/, 14];
                        _f.label = 4;
                    case 4:
                        _f.trys.push([4, 13, , 14]);
                        codec = STMPEncoding.get(ctx.get('content-type'));
                        ctx.action = handlers[0];
                        if (codec && ctx.incoming.payload) {
                            codec.decodeReq(ctx.incoming.payload, ctx);
                        }
                        _f.label = 5;
                    case 5:
                        _f.trys.push([5, 10, 11, 12]);
                        _c = __values(handlers[1]), _d = _c.next();
                        _f.label = 6;
                    case 6:
                        if (!!_d.done) return [3 /*break*/, 9];
                        h = _d.value;
                        return [4 /*yield*/, h(ctx)];
                    case 7:
                        _f.sent();
                        _f.label = 8;
                    case 8:
                        _d = _c.next();
                        return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 12];
                    case 10:
                        e_1_1 = _f.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 12];
                    case 11:
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        error_1 = _f.sent();
                        ctx.output('Internal Server Error', HTTP_INTERNAL_SERVER_ERROR);
                        this.emit('error', newError(STMPSource.HANDLE_REQUEST, { error: error_1, ctx: ctx }));
                        return [3 /*break*/, 14];
                    case 14:
                        this.emit('afterHandle', ctx);
                        _f.label = 15;
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    STMPClient.prototype.use = function (action, handler, options) {
        var handlers = this.handlers[action];
        if (handlers) {
            handlers[0] = options;
            handlers[1].push(handler);
        }
        else {
            this.handlers[action] = [options, [handler]];
        }
    };
    STMPClient.prototype.drop = function (action, handler) {
        var handlers = this.handlers[action];
        if (handlers) {
            splice(handlers[1], handler);
            if (handlers[1].length === 0) {
                delete this.handlers[action];
            }
        }
    };
    return STMPClient;
}(EventDispatcher));
export { STMPClient };
//# sourceMappingURL=STMPClient.js.map