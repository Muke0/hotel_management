/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 *
 * TODO
 */
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { Headers, Payload, STMPMessage } from './messages';
import { STMPContext } from './STMPContext';
import { STMPResponse } from './STMPResponse';
import { STMPAction, STMPError, STMPHandler, STMPSendOptions } from './types';
export interface ConnectingEvent {
    retryCount: number;
    remainCount: number;
    previousStatus: number | null;
    previousMessage: string | null;
}
export interface ConnectedEvent {
    status: number;
    message: string;
}
export interface ClosedEvent {
    status: number;
    message: string;
}
export interface STMPClientEventsMap {
    connecting: (event: ConnectingEvent) => void;
    connected: (event: ConnectedEvent) => void;
    closed: (event: ClosedEvent) => void;
    message: (message: STMPMessage) => void;
    error: (error: STMPError) => void;
    beforeHandle: (ctx: STMPContext<any, any, STMPClient>) => void;
    afterHandle: (ctx: STMPContext<any, any, STMPClient>) => void;
    response: (res: STMPResponse<any, any>) => void;
}
export interface STMPClientOptions {
    requestTimeout?: number;
    pingInterval?: number;
    pingTimeout?: number;
    autoPing?: boolean;
    handshakeTimeout?: number;
    maxRetryCount?: number;
    autoRetry?: boolean;
}
export declare abstract class STMPClient extends EventDispatcher<STMPClientEventsMap> {
    headers: Headers;
    readonly requestTimeout: number;
    readonly pingInterval: number;
    readonly pingTimeout: number;
    readonly autoPing: boolean;
    readonly handshakeTimeout: number;
    readonly maxRetryCount: number;
    readonly autoRetry: boolean;
    readyState: 'connecting' | 'connected' | 'closed';
    private nextId;
    private requests;
    private handlers;
    protected constructor(headers: Headers, options?: STMPClientOptions);
    protected startPing(): void;
    protected messageId(): number;
    push<Q>(action: string, body?: Payload | Q, headers?: Headers): void;
    push<Q>(options: STMPSendOptions<Q, any>): void;
    fetch<Q, S>(action: string, body?: Payload | Q, headers?: Headers): Promise<STMPResponse<S>>;
    fetch<Q, S>(options: STMPSendOptions<Q, S>): Promise<STMPResponse<S>>;
    close(status: number, message: string): void;
    protected processMessage(message: STMPMessage): Promise<void>;
    protected abstract terminate(): void;
    abstract connect(): Promise<[number, string]>;
    abstract send(message: STMPMessage): void;
    use<Q, S>(action: string, handler: STMPHandler<Q, S>, options?: STMPAction<Q, S>): void;
    drop<Q, S>(action: string, handler?: STMPHandler<Q, S>): void;
}
