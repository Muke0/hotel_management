"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-30 21:55:29
 *
 * TODO: limit pending message size for avoiding memory bomb
 */
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("./messages");
const varint_1 = require("./varint");
class StreamConsumer {
    constructor(maxPendingMessage = 4, maxTotalMessageSize = 1 << 24) {
        this.maxPendingMessage = maxPendingMessage;
        this.maxTotalMessageSize = maxTotalMessageSize;
        this.buf = Buffer.allocUnsafe(0);
        this.pendingMessages = Object.create(null);
        this.totalMessageSize = 0;
        this.pendingMessageCount = 0;
        this.messageLength = null;
    }
    checkVolume() {
        if (this.totalMessageSize > this.maxTotalMessageSize ||
            this.pendingMessageCount > this.maxPendingMessage) {
            for (const k in this.pendingMessages) {
                const m = this.pendingMessages[k];
                this.totalMessageSize -= m._bufLength;
                this.pendingMessageCount -= 1;
                this.checkVolume();
                return;
            }
        }
    }
    mergeMessage(message) {
        if (messages_1.isExchangeMessage(message)) {
            if (message.fin) {
                return message;
            }
            if (!message.payload) {
                message.payload = Buffer.allocUnsafe(0);
            }
            if (typeof message.payload === 'string') {
                message.payload = Buffer.from(message.payload);
            }
            message._buf = [message.payload];
            message._bufLength = message.payload.length;
            this.totalMessageSize += message._bufLength;
            this.pendingMessageCount += 1;
            this.pendingMessages[message.messageId] = message;
            this.checkVolume();
            return null;
        }
        else if (messages_1.isFollowMessage(message)) {
            if (!message.payload || message.payload.length === 0) {
                return null;
            }
            const host = this.pendingMessages[message.messageId];
            if (!host) {
                // TODO report error
                return null;
            }
            if (typeof message.payload === 'string') {
                message.payload = Buffer.from(message.payload);
            }
            host._buf.push(message.payload);
            if (message.fin) {
                this.totalMessageSize -= host._bufLength;
                this.pendingMessageCount -= 1;
                host.fin = true;
                host.payload = Buffer.concat(host._buf);
                delete host._bufLength;
                delete host._buf;
                delete this.pendingMessages[host.messageId];
                return host;
            }
            else {
                host._bufLength += message.payload.length;
                this.totalMessageSize += message.payload.length;
                this.checkVolume();
                return null;
            }
        }
        return message;
    }
    consumeFrame(data) {
        this.buf = Buffer.concat([this.buf, data]);
        if (this.messageLength === null) {
            this.messageLength = varint_1.readVarint(this.buf);
        }
        if (this.messageLength === null) {
            return;
        }
        const lengthBytes = varint_1.varintLength(this.messageLength);
        if (this.buf.length < this.messageLength + lengthBytes) {
            return;
        }
        const frame = this.buf.slice(lengthBytes, lengthBytes + this.messageLength);
        this.buf = this.buf.slice(lengthBytes + this.messageLength);
        this.messageLength = null;
        return frame;
    }
}
exports.StreamConsumer = StreamConsumer;
//# sourceMappingURL=StreamConsumer.js.map