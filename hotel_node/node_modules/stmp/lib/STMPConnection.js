"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 18:29:39
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const query_string_1 = require("monofile-utilities/lib/query-string");
const url_1 = tslib_1.__importDefault(require("url"));
const messages_1 = require("./messages");
const utils_1 = require("./utils");
class STMPConnection {
    constructor(server, socket) {
        this.server = server;
        this.socket = socket;
        this.groups = new Set();
        this.handshakeStatus = 0;
        this.closeStatus = 0;
        this.closeMessage = '';
        this.url = '';
        this.headers = messages_1.Headers();
        this.pathname = '';
        this.search = '';
        this.query = messages_1.Headers();
        this.nextId = 0;
    }
    init(url, headers) {
        var _a;
        this.url = url;
        headers['content-type'] = (_a = headers['content-type'], (_a !== null && _a !== void 0 ? _a : this.server.defaultContentType));
        this.headers = headers;
        const parsedUrl = url_1.default.parse(url);
        this.pathname = parsedUrl.pathname || '';
        this.search = parsedUrl.search || '';
        this.query = query_string_1.parse(parsedUrl.query || '');
    }
    authenticate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this.server.authenticate(this);
                this.handshake(messages_1.HTTP_OK, 'OK');
                if (this.handshakeStatus < 300) {
                    this.server.emit('connection', this);
                }
            }
            catch (e) {
                this.handshake(messages_1.HTTP_INTERNAL_SERVER_ERROR, 'Internal Server Error');
            }
        });
    }
    destroy(status, message) {
        var _a;
        this.closeStatus = status;
        this.closeMessage = message;
        this.server.connections.delete(this);
        (_a = this.groups) === null || _a === void 0 ? void 0 : _a.forEach((groupId) => this.leaveGroup(groupId));
        this.terminate();
    }
    processMessage(message) {
        if (messages_1.isCloseMessage(message)) {
            this.destroy(message.status, message.message);
        }
        else if (messages_1.isPingMessage(message)) {
            this.send(messages_1.createPingMessage(message.messageId));
        }
        else if (messages_1.isResponseMessage(message)) {
            // TODO: allow server request
        }
        else {
            this.server.processMessage(this, message);
        }
    }
    close(status = messages_1.WS_NORMAL_CLOSURE, message = 'Normal Closure') {
        if (this.closeStatus > 0 || status < 1000) {
            return;
        }
        this.send(messages_1.createCloseMessage(status, message));
        this.destroy(status, message);
    }
    joinGroup(groupId) {
        this.groups.add(groupId);
        const group = this.server.groups.get(groupId);
        if (group) {
            group.add(this);
        }
        else {
            this.server.groups.set(groupId, new Set([this]));
        }
    }
    leaveGroup(groupId) {
        var _a;
        this.groups.delete(groupId);
        (_a = this.server.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.delete(this);
    }
    handshake(status = messages_1.HTTP_OK, message = 'OK') {
        if (this.handshakeStatus > 0 || status < 100) {
            return;
        }
        this.handshakeStatus = status;
        this.sendHandshake(status, message);
    }
    messageId() {
        return (this.nextId = (this.nextId + 1) & 0xffff);
    }
    push(a, b, c) {
        const options = utils_1.normalizeSendOptions(a, b, c, this.headers);
        this.send(messages_1.createPushMessage(this.messageId(), options.action, options.payload, options.headers));
    }
}
exports.STMPConnection = STMPConnection;
//# sourceMappingURL=STMPConnection.js.map