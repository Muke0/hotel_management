/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:35:34
 *
 * FINE
 */
var _a, _b;
import { itos, stoi } from 'monofile-utilities/lib/numberFormat';
import { Headers, isExchangeMessage, isFollowMessage, MessageKind, } from './messages';
import { decodeString, encodeString, mapMap } from './utils';
var MessageKindText = mapMap((_a = {},
    _a[MessageKind.Ping] = 'p',
    _a[MessageKind.Request] = 'q',
    _a[MessageKind.Push] = 'n',
    _a[MessageKind.Response] = 's',
    _a[MessageKind.Follow] = 'f',
    _a[MessageKind.Close] = 'c',
    _a));
var MessageKindBinary = mapMap((_b = {},
    _b[MessageKind.Ping] = 128,
    _b[MessageKind.Request] = 144,
    _b[MessageKind.Push] = 160,
    _b[MessageKind.Response] = 176,
    _b[MessageKind.Close] = 192,
    _b[MessageKind.Follow] = 208,
    _b));
function parseTextPayload(input) {
    var newLine = input.indexOf('\n');
    var newNewLine = input.indexOf('\n\n');
    var rawHeaders = newNewLine > newLine ? input.substring(newLine + 1, newNewLine) : '';
    var headers = parseHeaders(rawHeaders);
    var payload = input.substring(newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
            ? newLine + 1
            : input.length) || void 0;
    return { headers: headers, payload: payload };
}
export function parseText(input) {
    var kind = MessageKindText.backward[input.charAt(0)];
    if (!kind || input.length < 2) {
        return null;
    }
    switch (kind) {
        case MessageKind.Ping:
            return { kind: kind, messageId: stoi(input.substr(1)) };
        case MessageKind.Request:
        case MessageKind.Push: {
            var space = input.indexOf(' ');
            var newLine = input.indexOf('\n', space);
            var action = decodeString(input.substring(space + 1, newLine > 0 ? newLine : void 0));
            var _a = parseTextPayload(input), payload = _a.payload, headers = _a.headers;
            return {
                kind: kind,
                messageId: stoi(input.substring(1, space)),
                action: action,
                headers: headers,
                payload: payload,
                fin: true,
            };
        }
        case MessageKind.Response: {
            var space = input.indexOf(' ', 1);
            if (space < 0) {
                return null;
            }
            var newLine = input.indexOf('\n', space);
            var _b = parseTextPayload(input), payload = _b.payload, headers = _b.headers;
            return {
                kind: kind,
                messageId: stoi(input.substring(1, space)),
                status: +input.substring(space + 1, newLine > 0 ? newLine : void 0),
                headers: headers,
                payload: payload,
                fin: true,
            };
        }
        case MessageKind.Close: {
            var newLine = input.indexOf('\n', 1);
            return {
                kind: kind,
                status: stoi(input.substring(1, newLine > 0 ? newLine : void 0)),
                message: newLine > 0 ? input.substr(newLine + 1) : '',
            };
        }
        case MessageKind.Follow: {
            var newLine = input.indexOf('\n', 1);
            if (newLine < 0 || newLine === input.length - 1) {
                return null;
            }
            var messageId = stoi(input.substring(1, newLine));
            var payload = input.substr(newLine + 1);
            return { kind: kind, fin: true, messageId: messageId, payload: payload };
        }
        default:
            throw new Error('unknown message kind');
    }
}
var CHAR_NEWLINE = '\n'.charCodeAt(0);
var NEW_NEW_LINE = new Uint8Array([CHAR_NEWLINE, CHAR_NEWLINE]);
function parseBinaryPayload(input, offset) {
    var newLine = input.indexOf(CHAR_NEWLINE, offset);
    var newNewLine = input.indexOf(NEW_NEW_LINE, offset);
    var rawHeaders = newNewLine > newLine ? input.slice(newLine + 1, newNewLine) : '';
    var headers = parseHeaders(rawHeaders.toString());
    var payload = input.slice(newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
            ? newLine + 1
            : input.length) || void 0;
    return { headers: headers, payload: payload.length > 0 ? payload : void 0 };
}
export function parseBinary(input) {
    if (input.length < 1) {
        return null;
    }
    var head = input[0];
    var kind = MessageKindBinary.backward[head & 240];
    if (!kind) {
        return null;
    }
    var fin = (head & 8) !== 0;
    switch (kind) {
        case MessageKind.Ping: {
            if (input.length < 3) {
                return null;
            }
            var messageId_1 = input.readUInt16BE(1);
            return { kind: kind, messageId: messageId_1 };
        }
        case MessageKind.Request:
        case MessageKind.Push: {
            if (input.length < 3) {
                return null;
            }
            var messageId_2 = input.readUInt16BE(1);
            var newLine = input.indexOf(CHAR_NEWLINE, 3);
            var action = decodeString(input.slice(3, newLine < 0 ? input.length : newLine).toString());
            var _a = parseBinaryPayload(input, 3), headers = _a.headers, payload_1 = _a.payload;
            return { kind: kind, action: action, payload: payload_1, fin: fin, messageId: messageId_2, headers: headers };
        }
        case MessageKind.Response: {
            var messageId_3 = input.readUInt16BE(1);
            if (input.length < 5) {
                return null;
            }
            var status_1 = input.readUInt16BE(3);
            var _b = parseBinaryPayload(input, 5), headers = _b.headers, payload_2 = _b.payload;
            return {
                kind: kind,
                status: status_1,
                payload: payload_2,
                fin: fin,
                messageId: messageId_3,
                headers: headers,
            };
        }
        case MessageKind.Close:
            if (input.length < 3) {
                return null;
            }
            var status_2 = input.readUInt16BE(1);
            var message = input.slice(3).toString('utf8');
            return { kind: kind, status: status_2, message: message };
        case MessageKind.Follow:
            if (input.length < 4) {
                return null;
            }
            var messageId = input.readUInt16BE(1);
            var payload = input.slice(3);
            return { kind: kind, payload: payload, messageId: messageId, fin: fin };
        default:
            throw new Error('unknown message kind');
    }
}
export function stringifyText(message) {
    var head = MessageKindText.forward[message.kind];
    switch (message.kind) {
        case MessageKind.Close:
            return (head +
                itos(message.status) +
                (message.message ? '\n' + message.message : ''));
        case MessageKind.Response:
            return (head +
                itos(message.messageId) +
                ' ' +
                message.status +
                stringifyHeaders(message.headers) +
                (message.payload ? '\n\n' + message.payload : ''));
        case MessageKind.Push:
        case MessageKind.Request:
            return (head +
                itos(message.messageId) +
                ' ' +
                encodeString(message.action) +
                stringifyHeaders(message.headers) +
                (message.payload ? '\n\n' + message.payload : ''));
        case MessageKind.Ping:
            return head + itos(message.messageId);
        case MessageKind.Follow:
            return head + itos(message.messageId) + '\n' + message.payload;
        default:
            throw new Error('unknown message kind');
    }
}
function appendPayload(head, headers, payload) {
    var bufHeaders = headers
        ? Buffer.from(stringifyHeaders(headers))
        : Buffer.allocUnsafe(0);
    if (!payload && !bufHeaders.length) {
        return head;
    }
    else if (payload instanceof Uint8Array && payload.byteLength > 0) {
        return Buffer.concat([head, bufHeaders, Buffer.from('\n\n'), payload]);
    }
    else if (typeof payload === 'string') {
        return Buffer.concat([
            head,
            bufHeaders,
            Buffer.from('\n\n'),
            Buffer.from(payload),
        ]);
    }
    else {
        return Buffer.concat([head, bufHeaders]);
    }
}
export function stringifyBinary(message) {
    var first = MessageKindBinary.forward[message.kind];
    if (isExchangeMessage(message) || isFollowMessage(message)) {
        first |= message.fin ? 8 : 0;
    }
    switch (message.kind) {
        case MessageKind.Ping: {
            var head_1 = Buffer.allocUnsafe(3);
            head_1.writeUInt8(first, 0);
            head_1.writeUInt16BE(message.messageId, 1);
            return head_1;
        }
        case MessageKind.Request:
        case MessageKind.Push: {
            var head_2 = Buffer.allocUnsafe(3);
            head_2.writeUInt8(first, 0);
            head_2.writeUInt16BE(message.messageId, 1);
            return appendPayload(Buffer.concat([head_2, Buffer.from(encodeString(message.action))]), message.headers, message.payload);
        }
        case MessageKind.Response: {
            var head_3 = Buffer.allocUnsafe(5);
            head_3.writeUInt8(first, 0);
            head_3.writeUInt16BE(message.messageId, 1);
            head_3.writeUInt16BE(message.status, 3);
            return appendPayload(head_3, message.headers, message.payload);
        }
        case MessageKind.Close: {
            var head_4 = Buffer.allocUnsafe(3);
            head_4.writeUInt8(first, 0);
            head_4.writeUInt16BE(message.status, 1);
            return Buffer.concat([head_4, Buffer.from(message.message)]);
        }
        case MessageKind.Follow:
            var head = Buffer.allocUnsafe(3);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.messageId, 1);
            if (!message.payload) {
                return head;
            }
            if (typeof message.payload === 'string') {
                return Buffer.concat([head, Buffer.from(message.payload)]);
            }
            return Buffer.concat([head, message.payload]);
        default:
            throw new Error('unknown message kind');
    }
}
export function parseHeaders(raw) {
    return raw
        .trim()
        .split('\n')
        .reduce(function (map, line) {
        var sepIndex = line.indexOf(':');
        if (sepIndex === -1) {
            return map;
        }
        var name = line
            .substr(0, sepIndex)
            .trim()
            .toLowerCase();
        map[decodeString(name)] = decodeString(line.substr(sepIndex + 1).trim());
        return map;
    }, Headers());
}
export function stringifyHeaders(headers) {
    return Object.keys(headers)
        .map(function (name) {
        var value = headers[name];
        return "\n" + encodeString(name) + ": " + encodeString(value);
    })
        .join('');
}
//# sourceMappingURL=protocol.js.map