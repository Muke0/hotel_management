/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:10:27
 */
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { P } from 'monofile-utilities/lib/types';
import { Headers, Payload, STMPMessage } from './messages';
import { STMPConnection } from './STMPConnection';
import { STMPContext } from './STMPContext';
import { STMPAction, STMPError, STMPHandler, STMPSendOptions } from './types';
export interface STMPServerEventsMap {
    /**
     * client connected, and handshake done
     */
    connection: (conn: STMPConnection) => void;
    /**
     * receive client message, which means Close message is always from client
     */
    message: (conn: STMPConnection, message: STMPMessage) => void;
    beforeHandle: (ctx: STMPContext) => P<void>;
    afterHandle: (ctx: STMPContext) => void;
    /**
     * when send Close message or receive client close message
     */
    close: (conn: STMPConnection, status: number, message: string) => void;
    error: (error: STMPError) => void;
}
export interface STMPServerOptions {
    defaultContentType?: string;
}
export interface STMPServerAdaptor {
    attach(server: STMPServer): void;
}
export declare type ConnFilter = (conn: STMPConnection) => boolean;
export declare class STMPServer extends EventDispatcher<STMPServerEventsMap> implements Required<Readonly<STMPServerOptions>> {
    readonly connections: Set<STMPConnection>;
    readonly groups: Map<string, Set<STMPConnection>>;
    readonly handlers: Map<string, [STMPAction | undefined, STMPHandler<any, any, STMPConnection>]>;
    readonly authenticate: (connection: STMPConnection) => P<void>;
    readonly defaultContentType: string;
    constructor(adaptors: STMPServerAdaptor[], authenticate?: (connection: STMPConnection) => P<void>, options?: STMPServerOptions);
    use<Q, S>(action: string, handler: STMPHandler<Q, S, STMPConnection>, options?: STMPAction<Q, S>): void;
    broadcast<Q>(action: string, data?: Q | Payload, headers?: Headers, filer?: ConnFilter): void;
    broadcast<Q>(options: STMPSendOptions<Q, any>, filter?: ConnFilter): void;
    pushGroup<Q>(groupId: string, action: string, data?: Payload | Q, headers?: Headers, filter?: ConnFilter): void;
    pushGroup<Q>(groupId: string, options: STMPSendOptions<Q, any>, filter?: ConnFilter): void;
    closeGroup(groupId: string, status?: number, message?: string): void;
    fireGroup(groupId: string): void;
}
