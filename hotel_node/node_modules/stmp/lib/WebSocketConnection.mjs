/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 18:28:54
 */
import { __extends } from "tslib";
import { debuglog } from 'util';
import { createCloseMessage, Headers, HTTP_OK, isCloseMessage, isExchangeMessage, WS_PROTOCOL_ERROR, } from './messages';
import { parseBinary, parseText, stringifyBinary, stringifyText, } from './protocol';
import { STMPConnection } from './STMPConnection';
var debug = debuglog('stmp:WebSocketConnection');
function normalizeHeaders(httpHeaders) {
    var headers = Headers();
    Object.keys(httpHeaders).forEach(function (k) {
        var v = httpHeaders[k];
        headers[k] = (Array.isArray(v) ? v[v.length - 1] : v) || '';
    });
    return headers;
}
var WebSocketConnection = /** @class */ (function (_super) {
    __extends(WebSocketConnection, _super);
    function WebSocketConnection(server, ws, request) {
        var _this = _super.call(this, server, request.socket) || this;
        _this.handleClose = function (code, reason) {
            _this.processMessage(createCloseMessage(code, reason));
        };
        _this.handleMessage = function (data) {
            var message;
            if (typeof data === 'string') {
                message = parseText(data);
            }
            else if (Array.isArray(data)) {
                message = parseBinary(Buffer.concat(data));
            }
            else if (!Buffer.isBuffer(data)) {
                message = parseBinary(Buffer.from(data));
            }
            else {
                message = parseBinary(data);
            }
            debug('receive message %s as %O.', data, message);
            if (!message) {
                _this.close(WS_PROTOCOL_ERROR);
                return;
            }
            _this.processMessage(message);
        };
        _this.request = request;
        _this.ws = ws;
        debug('handshake frame: %s %O.', request.url, request.headers);
        _this.init(request.url || '', normalizeHeaders(request.headers));
        Object.assign(_this.headers, _this.query.__stmp_headers__);
        _this.authenticate().then(function () {
            if (_this.handshakeStatus === HTTP_OK) {
                ws.on('message', _this.handleMessage);
                ws.on('close', _this.handleClose);
            }
        });
        return _this;
    }
    WebSocketConnection.prototype.send = function (message) {
        if (isCloseMessage(message)) {
            this.ws.close(message.status, message.message);
            return;
        }
        if (isExchangeMessage(message) && message.payload instanceof Uint8Array) {
            this.ws.send(stringifyBinary(message));
        }
        else {
            this.ws.send(stringifyText(message));
        }
    };
    WebSocketConnection.prototype.sendHandshake = function (status, message) {
        this.ws.send(message ? status + '\n' + message : status + '');
    };
    WebSocketConnection.prototype.terminate = function () {
        this.ws.removeAllListeners();
    };
    return WebSocketConnection;
}(STMPConnection));
export { WebSocketConnection };
//# sourceMappingURL=WebSocketConnection.js.map