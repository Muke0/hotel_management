"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 18:28:54
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const messages_1 = require("./messages");
const protocol_1 = require("./protocol");
const STMPConnection_1 = require("./STMPConnection");
const debug = util_1.debuglog('stmp:WebSocketConnection');
function normalizeHeaders(httpHeaders) {
    const headers = messages_1.Headers();
    Object.keys(httpHeaders).forEach((k) => {
        const v = httpHeaders[k];
        headers[k] = (Array.isArray(v) ? v[v.length - 1] : v) || '';
    });
    return headers;
}
class WebSocketConnection extends STMPConnection_1.STMPConnection {
    constructor(server, ws, request) {
        super(server, request.socket);
        this.handleClose = (code, reason) => {
            this.processMessage(messages_1.createCloseMessage(code, reason));
        };
        this.handleMessage = (data) => {
            let message;
            if (typeof data === 'string') {
                message = protocol_1.parseText(data);
            }
            else if (Array.isArray(data)) {
                message = protocol_1.parseBinary(Buffer.concat(data));
            }
            else if (!Buffer.isBuffer(data)) {
                message = protocol_1.parseBinary(Buffer.from(data));
            }
            else {
                message = protocol_1.parseBinary(data);
            }
            debug('receive message %s as %O.', data, message);
            if (!message) {
                this.close(messages_1.WS_PROTOCOL_ERROR);
                return;
            }
            this.processMessage(message);
        };
        this.request = request;
        this.ws = ws;
        debug('handshake frame: %s %O.', request.url, request.headers);
        this.init(request.url || '', normalizeHeaders(request.headers));
        Object.assign(this.headers, this.query.__stmp_headers__);
        this.authenticate().then(() => {
            if (this.handshakeStatus === messages_1.HTTP_OK) {
                ws.on('message', this.handleMessage);
                ws.on('close', this.handleClose);
            }
        });
    }
    send(message) {
        if (messages_1.isCloseMessage(message)) {
            this.ws.close(message.status, message.message);
            return;
        }
        if (messages_1.isExchangeMessage(message) && message.payload instanceof Uint8Array) {
            this.ws.send(protocol_1.stringifyBinary(message));
        }
        else {
            this.ws.send(protocol_1.stringifyText(message));
        }
    }
    sendHandshake(status, message) {
        this.ws.send(message ? status + '\n' + message : status + '');
    }
    terminate() {
        this.ws.removeAllListeners();
    }
}
exports.WebSocketConnection = WebSocketConnection;
//# sourceMappingURL=WebSocketConnection.js.map