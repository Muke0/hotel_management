/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 18:35:29
 */
import { __read, __spread } from "tslib";
import { Headers, isPayload } from './messages';
import { STMPEncoding } from './STMPEncoding';
import { writeVarint } from './varint';
export function mapMap(input) {
    var backward = {};
    for (var key in input) {
        if (input.hasOwnProperty(key)) {
            backward[input[key]] = key;
        }
    }
    return { forward: input, backward: backward };
}
export function b8(value, buf) {
    if (buf === void 0) { buf = Buffer.allocUnsafe(1); }
    buf.writeUInt8(value, 0);
    return buf;
}
export function b16(value, buf) {
    if (buf === void 0) { buf = Buffer.allocUnsafe(2); }
    buf.writeUInt16BE(value, 0);
    return buf;
}
export function b32(value, buf) {
    if (buf === void 0) { buf = Buffer.allocUnsafe(4); }
    buf.writeUInt32BE(value, 0);
    return buf;
}
export function createBuffer() {
    var chunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        chunks[_i] = arguments[_i];
    }
    return Buffer.concat(chunks.map(function (item) {
        if (typeof item === 'string') {
            return Buffer.from(item);
        }
        return item;
    }));
}
export function createPrefixedBuffer() {
    var chunks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        chunks[_i] = arguments[_i];
    }
    var content = createBuffer.apply(void 0, __spread(chunks));
    return Buffer.concat([writeVarint(content.length), content]);
}
/** @internal */
export function normalizeSendOptions(a, b, c, thisHeaders) {
    var _a, _b, _c;
    var options = typeof a === 'string'
        ? {
            action: a,
            data: b,
            headers: c,
        }
        : a;
    options.headers = options.headers || Headers();
    options.payloadRecord = options.payloadRecord || Headers();
    if (arguments.length < 4) {
        return options;
    }
    var headers = Headers();
    if (options.headers && options.headers !== thisHeaders) {
        for (var k in options.headers) {
            var key = k.toLowerCase();
            if (thisHeaders[key] !== options.headers[k]) {
                headers[k] = options.headers[k];
            }
        }
    }
    var contentType = (_c = (_b = (_a = options.contentType, (_a !== null && _a !== void 0 ? _a : options.headers['content-type'])), (_b !== null && _b !== void 0 ? _b : thisHeaders['content-type'])), (_c !== null && _c !== void 0 ? _c : 'application/json'));
    if (!isPayload(options.payloadRecord[contentType], false)) {
        if (isPayload(options.data)) {
            options.payloadRecord[contentType] = options.data;
        }
        else {
            var codec = STMPEncoding.get(contentType);
            if (!codec) {
                throw new Error("cannot encode media \"" + contentType + "\"");
            }
            options.payloadRecord[contentType] = codec.encodeReq(options.data, options);
        }
    }
    var payload = options.payloadRecord[contentType];
    return Object.setPrototypeOf({ headers: headers, payload: payload }, options);
}
export function encodeString(str) {
    return str
        .replace(/%/g, '%25')
        .replace(/:/g, '%3A')
        .replace(/\n/g, '%0A');
}
export function decodeString(str) {
    return str.replace(/%([0-9a-fA-F]{2})/g, function ($0, $1) {
        switch ($1) {
            case '25':
                return '%';
            case '3A':
            case '3a':
                return ':';
            case '0A':
            case '0a':
                return '\n';
            default:
                return $0;
        }
    });
}
/** @internal */
export function normalizeHeaders(headers) {
    Object.setPrototypeOf(headers, null);
    for (var k in headers) {
        var key = k.toLowerCase();
        if (k !== key) {
            headers[key] = headers[k];
            delete headers[k];
        }
    }
    return headers;
}
//# sourceMappingURL=utils.js.map