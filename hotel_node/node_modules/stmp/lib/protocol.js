"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:35:34
 *
 * FINE
 */
Object.defineProperty(exports, "__esModule", { value: true });
const numberFormat_1 = require("monofile-utilities/lib/numberFormat");
const messages_1 = require("./messages");
const utils_1 = require("./utils");
const MessageKindText = utils_1.mapMap({
    [messages_1.MessageKind.Ping]: 'p',
    [messages_1.MessageKind.Request]: 'q',
    [messages_1.MessageKind.Push]: 'n',
    [messages_1.MessageKind.Response]: 's',
    [messages_1.MessageKind.Follow]: 'f',
    [messages_1.MessageKind.Close]: 'c',
});
const MessageKindBinary = utils_1.mapMap({
    [messages_1.MessageKind.Ping]: 128,
    [messages_1.MessageKind.Request]: 144,
    [messages_1.MessageKind.Push]: 160,
    [messages_1.MessageKind.Response]: 176,
    [messages_1.MessageKind.Close]: 192,
    [messages_1.MessageKind.Follow]: 208,
});
function parseTextPayload(input) {
    const newLine = input.indexOf('\n');
    const newNewLine = input.indexOf('\n\n');
    const rawHeaders = newNewLine > newLine ? input.substring(newLine + 1, newNewLine) : '';
    const headers = parseHeaders(rawHeaders);
    const payload = input.substring(newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
            ? newLine + 1
            : input.length) || void 0;
    return { headers, payload };
}
function parseText(input) {
    const kind = MessageKindText.backward[input.charAt(0)];
    if (!kind || input.length < 2) {
        return null;
    }
    switch (kind) {
        case messages_1.MessageKind.Ping:
            return { kind, messageId: numberFormat_1.stoi(input.substr(1)) };
        case messages_1.MessageKind.Request:
        case messages_1.MessageKind.Push: {
            const space = input.indexOf(' ');
            const newLine = input.indexOf('\n', space);
            const action = utils_1.decodeString(input.substring(space + 1, newLine > 0 ? newLine : void 0));
            const { payload, headers } = parseTextPayload(input);
            return {
                kind,
                messageId: numberFormat_1.stoi(input.substring(1, space)),
                action,
                headers,
                payload,
                fin: true,
            };
        }
        case messages_1.MessageKind.Response: {
            const space = input.indexOf(' ', 1);
            if (space < 0) {
                return null;
            }
            const newLine = input.indexOf('\n', space);
            const { payload, headers } = parseTextPayload(input);
            return {
                kind,
                messageId: numberFormat_1.stoi(input.substring(1, space)),
                status: +input.substring(space + 1, newLine > 0 ? newLine : void 0),
                headers,
                payload,
                fin: true,
            };
        }
        case messages_1.MessageKind.Close: {
            const newLine = input.indexOf('\n', 1);
            return {
                kind,
                status: numberFormat_1.stoi(input.substring(1, newLine > 0 ? newLine : void 0)),
                message: newLine > 0 ? input.substr(newLine + 1) : '',
            };
        }
        case messages_1.MessageKind.Follow: {
            const newLine = input.indexOf('\n', 1);
            if (newLine < 0 || newLine === input.length - 1) {
                return null;
            }
            const messageId = numberFormat_1.stoi(input.substring(1, newLine));
            const payload = input.substr(newLine + 1);
            return { kind, fin: true, messageId, payload };
        }
        default:
            throw new Error('unknown message kind');
    }
}
exports.parseText = parseText;
const CHAR_NEWLINE = '\n'.charCodeAt(0);
const NEW_NEW_LINE = new Uint8Array([CHAR_NEWLINE, CHAR_NEWLINE]);
function parseBinaryPayload(input, offset) {
    const newLine = input.indexOf(CHAR_NEWLINE, offset);
    const newNewLine = input.indexOf(NEW_NEW_LINE, offset);
    const rawHeaders = newNewLine > newLine ? input.slice(newLine + 1, newNewLine) : '';
    const headers = parseHeaders(rawHeaders.toString());
    const payload = input.slice(newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
            ? newLine + 1
            : input.length) || void 0;
    return { headers, payload: payload.length > 0 ? payload : void 0 };
}
function parseBinary(input) {
    if (input.length < 1) {
        return null;
    }
    const head = input[0];
    const kind = MessageKindBinary.backward[head & 0b11110000];
    if (!kind) {
        return null;
    }
    const fin = (head & 0b1000) !== 0;
    switch (kind) {
        case messages_1.MessageKind.Ping: {
            if (input.length < 3) {
                return null;
            }
            const messageId = input.readUInt16BE(1);
            return { kind, messageId };
        }
        case messages_1.MessageKind.Request:
        case messages_1.MessageKind.Push: {
            if (input.length < 3) {
                return null;
            }
            const messageId = input.readUInt16BE(1);
            const newLine = input.indexOf(CHAR_NEWLINE, 3);
            const action = utils_1.decodeString(input.slice(3, newLine < 0 ? input.length : newLine).toString());
            const { headers, payload } = parseBinaryPayload(input, 3);
            return { kind, action, payload, fin, messageId, headers };
        }
        case messages_1.MessageKind.Response: {
            const messageId = input.readUInt16BE(1);
            if (input.length < 5) {
                return null;
            }
            const status = input.readUInt16BE(3);
            const { headers, payload } = parseBinaryPayload(input, 5);
            return {
                kind,
                status,
                payload,
                fin,
                messageId,
                headers,
            };
        }
        case messages_1.MessageKind.Close:
            if (input.length < 3) {
                return null;
            }
            const status = input.readUInt16BE(1);
            const message = input.slice(3).toString('utf8');
            return { kind, status, message };
        case messages_1.MessageKind.Follow:
            if (input.length < 4) {
                return null;
            }
            const messageId = input.readUInt16BE(1);
            const payload = input.slice(3);
            return { kind, payload, messageId, fin };
        default:
            throw new Error('unknown message kind');
    }
}
exports.parseBinary = parseBinary;
function stringifyText(message) {
    const head = MessageKindText.forward[message.kind];
    switch (message.kind) {
        case messages_1.MessageKind.Close:
            return (head +
                numberFormat_1.itos(message.status) +
                (message.message ? '\n' + message.message : ''));
        case messages_1.MessageKind.Response:
            return (head +
                numberFormat_1.itos(message.messageId) +
                ' ' +
                message.status +
                stringifyHeaders(message.headers) +
                (message.payload ? '\n\n' + message.payload : ''));
        case messages_1.MessageKind.Push:
        case messages_1.MessageKind.Request:
            return (head +
                numberFormat_1.itos(message.messageId) +
                ' ' +
                utils_1.encodeString(message.action) +
                stringifyHeaders(message.headers) +
                (message.payload ? '\n\n' + message.payload : ''));
        case messages_1.MessageKind.Ping:
            return head + numberFormat_1.itos(message.messageId);
        case messages_1.MessageKind.Follow:
            return head + numberFormat_1.itos(message.messageId) + '\n' + message.payload;
        default:
            throw new Error('unknown message kind');
    }
}
exports.stringifyText = stringifyText;
function appendPayload(head, headers, payload) {
    const bufHeaders = headers
        ? Buffer.from(stringifyHeaders(headers))
        : Buffer.allocUnsafe(0);
    if (!payload && !bufHeaders.length) {
        return head;
    }
    else if (payload instanceof Uint8Array && payload.byteLength > 0) {
        return Buffer.concat([head, bufHeaders, Buffer.from('\n\n'), payload]);
    }
    else if (typeof payload === 'string') {
        return Buffer.concat([
            head,
            bufHeaders,
            Buffer.from('\n\n'),
            Buffer.from(payload),
        ]);
    }
    else {
        return Buffer.concat([head, bufHeaders]);
    }
}
function stringifyBinary(message) {
    let first = MessageKindBinary.forward[message.kind];
    if (messages_1.isExchangeMessage(message) || messages_1.isFollowMessage(message)) {
        first |= message.fin ? 0b1000 : 0;
    }
    switch (message.kind) {
        case messages_1.MessageKind.Ping: {
            const head = Buffer.allocUnsafe(3);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.messageId, 1);
            return head;
        }
        case messages_1.MessageKind.Request:
        case messages_1.MessageKind.Push: {
            const head = Buffer.allocUnsafe(3);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.messageId, 1);
            return appendPayload(Buffer.concat([head, Buffer.from(utils_1.encodeString(message.action))]), message.headers, message.payload);
        }
        case messages_1.MessageKind.Response: {
            const head = Buffer.allocUnsafe(5);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.messageId, 1);
            head.writeUInt16BE(message.status, 3);
            return appendPayload(head, message.headers, message.payload);
        }
        case messages_1.MessageKind.Close: {
            const head = Buffer.allocUnsafe(3);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.status, 1);
            return Buffer.concat([head, Buffer.from(message.message)]);
        }
        case messages_1.MessageKind.Follow:
            const head = Buffer.allocUnsafe(3);
            head.writeUInt8(first, 0);
            head.writeUInt16BE(message.messageId, 1);
            if (!message.payload) {
                return head;
            }
            if (typeof message.payload === 'string') {
                return Buffer.concat([head, Buffer.from(message.payload)]);
            }
            return Buffer.concat([head, message.payload]);
        default:
            throw new Error('unknown message kind');
    }
}
exports.stringifyBinary = stringifyBinary;
function parseHeaders(raw) {
    return raw
        .trim()
        .split('\n')
        .reduce((map, line) => {
        const sepIndex = line.indexOf(':');
        if (sepIndex === -1) {
            return map;
        }
        const name = line
            .substr(0, sepIndex)
            .trim()
            .toLowerCase();
        map[utils_1.decodeString(name)] = utils_1.decodeString(line.substr(sepIndex + 1).trim());
        return map;
    }, messages_1.Headers());
}
exports.parseHeaders = parseHeaders;
function stringifyHeaders(headers) {
    return Object.keys(headers)
        .map((name) => {
        const value = headers[name];
        return `\n${utils_1.encodeString(name)}: ${utils_1.encodeString(value)}`;
    })
        .join('');
}
exports.stringifyHeaders = stringifyHeaders;
//# sourceMappingURL=protocol.js.map