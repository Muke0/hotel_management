/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 */
import { __extends } from "tslib";
import net from 'net';
import { debuglog } from 'util';
import { Headers, isCloseMessage, WS_ABNORMAL_CLOSURE, WS_PROTOCOL_ERROR, } from './messages';
import { parseBinary, stringifyBinary, stringifyHeaders } from './protocol';
import { STMPClient } from './STMPClient';
import { StreamConsumer } from './StreamConsumer';
import { newError, STMPSource } from './types';
import { createPrefixedBuffer } from './utils';
var debug = debuglog('stmp:TCPClient');
var TCPClient = /** @class */ (function (_super) {
    __extends(TCPClient, _super);
    function TCPClient(host, port, url, headers, options) {
        if (headers === void 0) { headers = Headers(); }
        var _this = _super.call(this, headers, options) || this;
        _this.handleMessageData = function (data) {
            var frame = _this.consumer.consumeFrame(data);
            if (!frame) {
                return;
            }
            var message = parseBinary(frame);
            if (!message) {
                _this.close(WS_PROTOCOL_ERROR, 'Protocol Error');
                return;
            }
            message = _this.consumer.mergeMessage(message);
            if (message === null) {
                return;
            }
            _this.processMessage(message);
        };
        _this.host = host;
        _this.port = port;
        _this.url = url || '/';
        _this.consumer = new StreamConsumer();
        return _this;
    }
    TCPClient.prototype.connect = function (remainCount, previousStatus, previousMessage) {
        var _this = this;
        if (remainCount === void 0) { remainCount = this.maxRetryCount; }
        if (previousStatus === void 0) { previousStatus = null; }
        if (previousMessage === void 0) { previousMessage = null; }
        if (this.readyState !== 'closed') {
            return Promise.reject(new Error("cannot connect with readyState: " + this.readyState));
        }
        var timeoutHandler;
        this.readyState = 'connecting';
        this.emit('connecting', {
            remainCount: remainCount,
            retryCount: this.maxRetryCount - remainCount,
            previousStatus: previousStatus,
            previousMessage: previousMessage,
        });
        return new Promise(function (resolve, reject) {
            var socket = (_this.socket = net.createConnection(_this.port, _this.host));
            timeoutHandler = setTimeout(function () {
                reject(new Error('connect timeout'));
            }, _this.handshakeTimeout);
            var openHandler = function () {
                socket.write(createPrefixedBuffer(_this.url + stringifyHeaders(_this.headers)));
            };
            var handshakeHandler = function (data) {
                var header = _this.consumer.consumeFrame(data);
                if (!header) {
                    return;
                }
                if (header.length < 2) {
                    reject(new Error('invalid handshake frame'));
                    return;
                }
                var status = header.readUInt16BE(0);
                var message = header.slice(2).toString('utf8');
                debug('handshake response [%s]: %s.', status, message);
                if (status > 299) {
                    reject({ status: status, message: message });
                }
                else {
                    clearTimeout(timeoutHandler);
                    socket.removeAllListeners();
                    _this.readyState = 'connected';
                    _this.emit('connected', { status: status, message: message });
                    socket.on('data', _this.handleMessageData);
                    socket.on('error', function (error) {
                        _this.emit('error', newError(STMPSource.TRANSPORT_ERROR, { error: error }));
                    });
                    socket.on('close', function () {
                        _this.close(WS_ABNORMAL_CLOSURE, 'Socket Closed');
                    });
                    resolve([status, message]);
                }
            };
            socket.on('connect', openHandler);
            socket.on('data', handshakeHandler);
            socket.on('error', reject);
            socket.on('close', reject);
        }).catch(function (reason) {
            var _a, _b;
            clearTimeout(timeoutHandler);
            _this.socket.removeAllListeners();
            _this.readyState = 'closed';
            if (remainCount > 0) {
                return _this.connect(remainCount - 1, (_a = reason) === null || _a === void 0 ? void 0 : _a.status, (_b = reason) === null || _b === void 0 ? void 0 : _b.message);
            }
            else {
                return Promise.reject(reason);
            }
        });
    };
    TCPClient.prototype.send = function (message) {
        if (isCloseMessage(message) && !this.socket.writable) {
            return;
        }
        this.socket.write(createPrefixedBuffer(stringifyBinary(message)));
    };
    TCPClient.prototype.terminate = function () {
        this.socket.removeAllListeners();
        this.socket.end();
    };
    return TCPClient;
}(STMPClient));
export { TCPClient };
//# sourceMappingURL=TCPClient.js.map