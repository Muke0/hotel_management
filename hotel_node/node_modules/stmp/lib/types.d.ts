/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:35:44
 *
 * shared types for client & server
 * TODO
 */
import { P } from 'monofile-utilities/lib/types';
import { CloseMessage, Headers, Payload, ResponseMessage, STMPMessage } from './messages';
import { STMPClient } from './STMPClient';
import { STMPConnection } from './STMPConnection';
import { STMPContext } from './STMPContext';
declare global {
    namespace stmp {
        interface Connection {
        }
        interface Context<Q, S> {
        }
        interface Response<S, Q> {
        }
        interface SendOptions<Q, S> {
        }
        interface Action<Q, S> {
        }
    }
}
export declare type STMPHandler<Q = any, S = any, I extends STMPInstance = STMPInstance> = (ctx: STMPContext<Q, S, I>) => P<void>;
export interface STMPAction<Q = any, S = any> extends stmp.Action<Q, S> {
}
export interface STMPInstance {
    headers: Headers;
    send(message: STMPMessage): void;
}
export interface STMPSendOptions<Q = any, S = any> extends stmp.SendOptions<Q, S> {
    action: string;
    contentType?: string;
    headers?: Headers;
    data?: Q | Payload;
}
export declare enum STMPSource {
    HANDLE_REQUEST = "HANDLE_REQUEST",
    STATUS_NOT_OK = "STATUS_NOT_OK",
    REQUEST_TIMEOUT = "REQUEST_TIMEOUT",
    TRANSPORT_ERROR = "TRANSPORT_ERROR",
    CONNECTION_CLOSED = "CONNECTION_CLOSED",
    PARSE_RESPONSE_ERROR = "PARSE_RESPONSE_ERROR"
}
export interface STMPError extends Error {
    error: Error;
    event: Event;
    source: STMPSource;
    ctx: STMPContext;
    conn: STMPConnection;
    client: STMPClient;
    req: STMPSendOptions<any, any>;
    res: ResponseMessage;
    close: CloseMessage;
}
export declare function newError(source: STMPSource, options?: Partial<STMPError>): STMPError;
export declare function isSTMPError(error: unknown): error is STMPError;
