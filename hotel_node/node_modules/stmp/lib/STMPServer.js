"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:10:27
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const consts_1 = require("monofile-utilities/lib/consts");
const EventDispatcher_1 = require("monofile-utilities/lib/EventDispatcher");
const util_1 = require("util");
const messages_1 = require("./messages");
const STMPContext_1 = require("./STMPContext");
const STMPEncoding_1 = require("./STMPEncoding");
const types_1 = require("./types");
const utils_1 = require("./utils");
// @ts-ignore
const debug = util_1.debuglog('stmp:STMPServer');
class STMPServer extends EventDispatcher_1.EventDispatcher {
    constructor(adaptors, authenticate = consts_1.noop, options = {}) {
        var _a;
        super();
        this.authenticate = authenticate;
        this.connections = new Set();
        this.groups = new Map();
        this.handlers = new Map();
        this.defaultContentType = (_a = options.defaultContentType, (_a !== null && _a !== void 0 ? _a : 'application/json'));
        adaptors.forEach((adaptor) => adaptor.attach(this));
    }
    /** @internal */
    processMessage(connection, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.emit('message', connection, message);
            if (!messages_1.isIncomeMessage(message)) {
                return;
            }
            const handler = this.handlers.get(message.action);
            const ctx = new STMPContext_1.STMPContext(message, connection);
            try {
                yield this.emitSerial('beforeHandle', ctx);
                if (ctx.isFinished()) {
                    this.emit('afterHandle', ctx);
                    return;
                }
                if (!handler) {
                    ctx.text('Not Found', messages_1.HTTP_NOT_FOUND);
                    this.emit('afterHandle', ctx);
                    return;
                }
                if (ctx.input === void 0 && ctx.incoming.payload) {
                    const codec = STMPEncoding_1.STMPEncoding.get(ctx.get('content-type'));
                    if (codec) {
                        ctx.input = codec.decodeReq(ctx.incoming.payload, ctx);
                    }
                }
                yield handler[1](ctx);
            }
            catch (error) {
                if (!ctx.isFinished()) {
                    ctx.text('Internal Server Error', messages_1.HTTP_INTERNAL_SERVER_ERROR);
                }
                debug('handle %s, internal server error: %s.', message.action, error);
                this.emit('error', types_1.newError(types_1.STMPSource.HANDLE_REQUEST, { error, ctx }));
            }
            yield this.emitSerial('afterHandle', ctx);
            if (!ctx.isFinished()) {
                ctx.text('Not Found', messages_1.HTTP_NOT_FOUND);
            }
        });
    }
    use(action, handler, options) {
        this.handlers.set(action, [options, handler]);
    }
    broadcast(a, b, c, d) {
        const options = typeof a === 'string'
            ? {
                action: a,
                data: b,
                headers: c,
            }
            : a;
        const filter = typeof a === 'string' ? d : b;
        if (filter) {
            this.connections.forEach((c) => filter(c) && c.push(options));
        }
        else {
            this.connections.forEach((c) => c.push(options));
        }
    }
    pushGroup(groupId, a, b, c, d) {
        var _a, _b;
        const options = utils_1.normalizeSendOptions(a, b, c);
        const filter = typeof a === 'string' ? d : b;
        if (filter) {
            (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach((c) => filter(c) && c.push(options));
        }
        else {
            (_b = this.groups.get(groupId)) === null || _b === void 0 ? void 0 : _b.forEach((c) => c.push(options));
        }
    }
    closeGroup(groupId, status, message) {
        var _a;
        (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach((conn) => conn.close(status, message));
    }
    fireGroup(groupId) {
        var _a;
        (_a = this.groups.get(groupId)) === null || _a === void 0 ? void 0 : _a.forEach((conn) => conn.leaveGroup(groupId));
    }
}
exports.STMPServer = STMPServer;
//# sourceMappingURL=STMPServer.js.map