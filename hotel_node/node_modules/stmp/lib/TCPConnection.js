"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 17:51:35
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const messages_1 = require("./messages");
const protocol_1 = require("./protocol");
const STMPConnection_1 = require("./STMPConnection");
const StreamConsumer_1 = require("./StreamConsumer");
const utils_1 = require("./utils");
const debug = util_1.debuglog('stmp:TCPConnection');
const HANDSHAKE_TIMEOUT = utils_1.createPrefixedBuffer(utils_1.b16(messages_1.HTTP_REQUEST_TIMEOUT));
const HANDSHAKE_BAD_REQUEST = utils_1.createPrefixedBuffer(utils_1.b16(messages_1.HTTP_BAD_REQUEST));
class TCPConnection extends STMPConnection_1.STMPConnection {
    constructor(server, socket) {
        super(server, socket);
        this.handleHandshakeData = (data) => {
            const header = this.consumer.consumeFrame(data);
            if (!header) {
                return;
            }
            debug('handshake frame: %s.', header);
            clearTimeout(this.handshakeTimer);
            this.handshakeTimer = undefined;
            if (header.length < 1) {
                this.socket.end(HANDSHAKE_BAD_REQUEST);
                return;
            }
            const handshake = header.toString();
            const newLine = handshake.indexOf('\n');
            const url = newLine < 0 ? handshake : handshake.substr(0, newLine);
            const headers = newLine < 0 ? messages_1.Headers() : protocol_1.parseHeaders(handshake.substr(newLine + 1));
            this.socket.removeListener('data', this.handleHandshakeData);
            this.init(url, headers);
            this.authenticate().then(() => {
                if (this.handshakeStatus === messages_1.HTTP_OK) {
                    this.socket.on('data', this.handleMessageData);
                }
            });
        };
        this.handleMessageData = (data) => {
            const frame = this.consumer.consumeFrame(data);
            if (!frame) {
                return;
            }
            let message = protocol_1.parseBinary(frame);
            debug('receive message frame: %s as %s to %O.', data, frame, message);
            if (!message) {
                this.close(messages_1.WS_PROTOCOL_ERROR);
                return;
            }
            message = this.consumer.mergeMessage(message);
            if (message === null) {
                return;
            }
            this.processMessage(message);
        };
        this.handleHandshakeTimeout = () => {
            this.socket.removeAllListeners('data');
            this.socket.end(HANDSHAKE_TIMEOUT);
        };
        this.consumer = new StreamConsumer_1.StreamConsumer();
    }
    prepare(handshakeTimeout) {
        this.handshakeTimer = setTimeout(this.handleHandshakeTimeout, handshakeTimeout);
        this.socket.on('data', this.handleHandshakeData);
    }
    send(message) {
        const buf = protocol_1.stringifyBinary(message);
        this.socket.write(utils_1.createPrefixedBuffer(buf));
    }
    sendHandshake(status, message) {
        this.socket.write(utils_1.createPrefixedBuffer(utils_1.b16(status), message));
    }
    terminate() {
        this.socket.removeAllListeners();
        this.socket.end();
    }
}
exports.TCPConnection = TCPConnection;
//# sourceMappingURL=TCPConnection.js.map