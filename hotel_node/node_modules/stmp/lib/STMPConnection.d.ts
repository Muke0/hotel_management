/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 18:29:39
 */
/// <reference types="node" />
import net from 'net';
import { Headers, Payload, STMPMessage } from './messages';
import { STMPServer } from './STMPServer';
import { STMPSendOptions } from './types';
export interface STMPConnection extends stmp.Connection {
}
export declare type ExtendedQuery = {
    [P in string | number]: string | string[] | ExtendedQuery;
};
export declare abstract class STMPConnection {
    url: string;
    headers: Headers;
    pathname: string;
    search: string;
    query: ExtendedQuery;
    server: STMPServer;
    socket: net.Socket;
    groups: Set<string>;
    handshakeStatus: number;
    closeStatus: number;
    closeMessage: string;
    private nextId;
    protected constructor(server: STMPServer, socket: net.Socket);
    protected init(url: string, headers: Headers): void;
    protected authenticate(): Promise<void>;
    private destroy;
    protected processMessage(message: STMPMessage): void;
    close(status?: number, message?: string): void;
    joinGroup(groupId: string): void;
    leaveGroup(groupId: string): void;
    handshake(status?: number, message?: string): void;
    messageId(): number;
    push<Q>(action: string, data?: Q | Payload, headers?: Headers): void;
    push<Q>(options: STMPSendOptions<Q, any>): void;
    protected abstract terminate(): void;
    protected abstract sendHandshake(status: number, message: string): void;
    abstract send(message: STMPMessage): void;
}
