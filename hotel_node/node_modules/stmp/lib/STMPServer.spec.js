"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-28 19:24:16
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http_1 = tslib_1.__importDefault(require("http"));
const consts_1 = require("monofile-utilities/lib/consts");
const sleep_1 = require("monofile-utilities/lib/sleep");
const net_1 = tslib_1.__importDefault(require("net"));
const util_1 = require("util");
const ws_1 = tslib_1.__importDefault(require("ws"));
const json_1 = require("./codec/json");
const msgpack_lite_1 = require("./codec/msgpack-lite");
const messages_1 = require("./messages");
const STMPEncoding_1 = require("./STMPEncoding");
const STMPServer_1 = require("./STMPServer");
const TCPAdaptor_1 = require("./TCPAdaptor");
const TCPClient_1 = require("./TCPClient");
const WebSocketAdaptor_1 = require("./WebSocketAdaptor");
const WebSocketClient_1 = require("./WebSocketClient");
const debug = util_1.debuglog('stmp:STMPServer.spec');
function bufferMessage(message, binary) {
    if ((messages_1.isExchangeMessage(message) || messages_1.isFollowMessage(message)) &&
        typeof message.payload === 'string' &&
        binary) {
        return Object.assign(Object.assign({}, message), { payload: Buffer.from(message.payload) });
    }
    return message;
}
describe('STMPServer', () => {
    const disposers = [];
    beforeEach(() => {
        disposers.forEach((d) => {
            try {
                d();
            }
            catch (e) {
                console.error('dispose error', e);
            }
        });
    });
    it('should works as expected', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const expects = [];
        const actuals = [];
        const tcpServer = new net_1.default.Server({ allowHalfOpen: false });
        const httpServer = new http_1.default.Server();
        const wsServer = new ws_1.default.Server({ server: httpServer });
        const stmpServer = new STMPServer_1.STMPServer([
            new TCPAdaptor_1.TCPAdaptor(tcpServer),
            new WebSocketAdaptor_1.WebSocketAdaptor(wsServer),
        ]);
        stmpServer.on('message', (connection, message) => {
            actuals.push('server message', message);
        });
        stmpServer.use('test.echo', (ctx) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            yield sleep_1.sleep(1);
            actuals.push('server use test.echo', ctx.incoming);
            debug('server test.echo input %O.', ctx.input);
            ctx.output(ctx.input);
        }));
        stmpServer.use('test.error', (ctx) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            yield sleep_1.sleep(1);
            actuals.push('server use test.error', ctx.incoming);
            throw new Error('test.error');
        }));
        stmpServer.use('test.push', (ctx) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            yield sleep_1.sleep(1);
            setTimeout(() => ctx.instance.push('test.push', ctx.incoming.payload, ctx.instance.headers), 100);
        }));
        tcpServer.listen(3001);
        disposers.push(() => tcpServer.close());
        httpServer.listen(3002);
        disposers.push(() => httpServer.close());
        yield sleep_1.sleep(consts_1.T_SECOND);
        const invokeClient = (kind, client, codec, binary) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            client.on('message', (message) => {
                actuals.push('client message', kind, message);
            });
            client.on('connecting', (event) => {
                actuals.push('client connecting', kind, event);
            });
            client.on('connected', (event) => {
                actuals.push('client connected', kind, event);
            });
            client.on('closed', (event) => {
                actuals.push('client closed', kind, event);
            });
            client.use('test.push', (ctx) => {
                actuals.push('client push', kind, ctx.incoming);
            });
            yield client.connect();
            debug('%s client connected.', kind);
            expects.push('client connecting', kind, {
                retryCount: 0,
                remainCount: client.maxRetryCount,
                previousStatus: null,
                previousMessage: null,
            });
            expects.push('client connected', kind, {
                status: 200,
                message: 'OK',
            });
            const echoInput = { hello: 'world' };
            const echoRes = yield client.fetch('test.echo', echoInput);
            const echoRequestMessage = bufferMessage(messages_1.createRequestMessage(1, 'test.echo', codec.encode(echoInput)), binary);
            actuals.push('client test.echo response', kind, echoRes.data);
            expects.push('server message', echoRequestMessage);
            expects.push('server use test.echo', echoRequestMessage);
            expects.push('client message', kind, bufferMessage(messages_1.createResponseMessage(1, 200, codec.encode(echoInput)), binary));
            expects.push('client test.echo response', kind, echoInput);
            const errorInput = { error: 'test' };
            let errorError = consts_1.ANY;
            try {
                yield client.fetch('test.error', errorInput);
            }
            catch (e) {
                errorError = e;
            }
            const errorRequestMessage = bufferMessage(messages_1.createRequestMessage(2, 'test.error', codec.encode(errorInput)), binary);
            actuals.push('client test.error error', errorError.res);
            expects.push('server message', errorRequestMessage);
            expects.push('server use test.error', errorRequestMessage);
            const errorResponseMessage = bufferMessage(messages_1.createResponseMessage(2, 500, 'Internal Server Error', {
                'content-type': 'text/plain',
            }), binary);
            expects.push('client message', kind, errorResponseMessage);
            expects.push('client test.error error', errorResponseMessage);
            const pushInput = { hello: 'world' };
            client.push('test.push', pushInput);
            const pushPushMessage = bufferMessage(messages_1.createPushMessage(3, 'test.push', codec.encode(pushInput)), binary);
            expects.push('server message', pushPushMessage);
            const pushReceiveMessage = bufferMessage(messages_1.createPushMessage(1, 'test.push', codec.encode(pushInput)), binary);
            expects.push('client message', kind, pushReceiveMessage);
            expects.push('client push', kind, pushReceiveMessage);
            yield sleep_1.sleep(200);
        });
        const closeClient = (kind, client) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            debug('close client kind: %s.', kind);
            client.close(messages_1.WS_NORMAL_CLOSURE, 'Normal Closure');
            expects.push('client closed', kind, messages_1.createCloseMessage(messages_1.WS_NORMAL_CLOSURE, 'Normal Closure'));
        });
        const tcpClient = new TCPClient_1.TCPClient('127.0.0.1', 3001, '/');
        const wsClient = new WebSocketClient_1.WebSocketClient('ws://127.0.0.1:3002/');
        yield invokeClient('tcp', tcpClient, json_1.jsonCodec, true);
        yield invokeClient('ws', wsClient, json_1.jsonCodec, false);
        yield closeClient('tcp', tcpClient);
        yield closeClient('ws', wsClient);
        STMPEncoding_1.STMPEncoding.register(msgpack_lite_1.msgpackCodec);
        const msgpackClient = new TCPClient_1.TCPClient('127.0.0.1', 3001, '/', {
            'content-type': msgpack_lite_1.msgpackCodec.contentType[0],
        });
        yield invokeClient('msgpack', msgpackClient, msgpack_lite_1.msgpackCodec, true);
        yield closeClient('msgpack', msgpackClient);
        expect(actuals).toEqual(expects);
        expect(stmpServer.connections.size).toBe(0);
    }));
});
//# sourceMappingURL=STMPServer.spec.js.map