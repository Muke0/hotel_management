"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 20:45:47
 *
 * FINE
 */
Object.defineProperty(exports, "__esModule", { value: true });
const numberFormat_1 = require("monofile-utilities/lib/numberFormat");
const messages_1 = require("./messages");
const protocol_1 = require("./protocol");
const utils_1 = require("./utils");
const protocolSpecCases = [
    {
        name: 'ping',
        message: messages_1.createPingMessage(0xff),
        text: 'p' + numberFormat_1.itos(0xff),
        binary: utils_1.createBuffer(utils_1.b8(128), utils_1.b16(0xff)),
    },
    {
        name: 'close',
        message: messages_1.createCloseMessage(1009, 'ä¸­æ–‡'),
        text: 'c' + numberFormat_1.itos(1009) + '\nä¸­æ–‡',
        binary: utils_1.createBuffer(utils_1.b8(192), utils_1.b16(1009), 'ä¸­æ–‡'),
    },
    {
        name: 'request',
        message: messages_1.createRequestMessage(0xffff, 'room.enter', 'Hello: ðŸ˜‚\nworld: \n\n!'),
        text: 'q' + numberFormat_1.itos(0xffff) + ' room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
        binary: utils_1.createBuffer(utils_1.b8(152), utils_1.b16(0xffff), 'room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!'),
    },
    {
        name: 'notify',
        message: messages_1.createPushMessage(0xff, 'room.enter', 'Hello: ðŸ˜‚\nworld: \n\n!'),
        text: 'n' + numberFormat_1.itos(0xff) + ' room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
        binary: utils_1.createBuffer(utils_1.b8(168), utils_1.b16(0xff), 'room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!'),
    },
    {
        name: 'response',
        message: messages_1.createResponseMessage(0xff0f, 200, 'Hello: ðŸ˜‚\nworld: \n\n!'),
        text: 's' + numberFormat_1.itos(0xff0f) + ' 200' + '\n\nHello: ðŸ˜‚\nworld: \n\n!',
        binary: utils_1.createBuffer(utils_1.b8(184), utils_1.b16(0xff0f), utils_1.b16(200), '\n\nHello: ðŸ˜‚\nworld: \n\n!'),
    },
    {
        name: 'request header',
        message: messages_1.createRequestMessage(0xff, 'echo%\n', 'Hello: ðŸ˜‚\nworld: \n\n!', {
            'key:name': 'value%:\nname',
        }),
        text: 'q' +
            numberFormat_1.itos(0xff) +
            ' echo%25%0A\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
        binary: utils_1.createBuffer(utils_1.b8(152), utils_1.b16(0xff), 'echo%25%0A\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!'),
    },
    {
        name: 'response header',
        message: messages_1.createResponseMessage(0xff, 200, 'Hello: ðŸ˜‚\nworld: \n\n!', {
            'key:name': 'value%:\nname',
        }),
        text: 's' +
            numberFormat_1.itos(0xff) +
            ' 200\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
        binary: utils_1.createBuffer(utils_1.b8(184), utils_1.b16(0xff), utils_1.b16(200), '\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!'),
    },
    {
        name: 'request empty',
        message: messages_1.createRequestMessage(0xff, 'echo', void 0),
        text: 'q' + numberFormat_1.itos(0xff) + ' echo',
        binary: utils_1.createBuffer(utils_1.b8(152), utils_1.b16(0xff), 'echo'),
    },
    {
        name: 'response empty',
        message: messages_1.createResponseMessage(0xff, 200, void 0),
        text: 's' + numberFormat_1.itos(0xff) + ' 200',
        binary: utils_1.createBuffer(utils_1.b8(184), utils_1.b16(0xff), utils_1.b16(200)),
    },
    {
        name: 'close empty',
        message: messages_1.createCloseMessage(1009, ''),
        text: 'c' + numberFormat_1.itos(1009),
        binary: utils_1.createBuffer(utils_1.b8(192), utils_1.b16(1009)),
    },
    {
        name: 'follow',
        message: messages_1.createFollowMessage(0xff, 'hello world!'),
        text: 'f' + numberFormat_1.itos(0xff) + '\nhello world!',
        binary: utils_1.createBuffer(utils_1.b8(216), utils_1.b16(0xff), 'hello world!'),
    },
];
describe('protocol', () => {
    for (const { name, binary, message, text } of protocolSpecCases) {
        if (text !== null) {
            it(`should parse text ${name}`, () => {
                const parsed = protocol_1.parseText(text);
                expect(parsed).toEqual(message);
            });
        }
        it(`should parse binary ${name}`, () => {
            const parsed = protocol_1.parseBinary(binary);
            if (parsed && 'payload' in parsed && parsed.payload instanceof Buffer) {
                parsed.payload = parsed.payload.toString('utf8');
            }
            expect(parsed).toEqual(message);
        });
        if (text !== null) {
            it(`should stringify text ${name}`, () => {
                expect(protocol_1.stringifyText(message)).toBe(text);
            });
        }
        it(`should stringify binary ${name}`, () => {
            expect(protocol_1.stringifyBinary(message)).toEqual(binary);
        });
    }
});
//# sourceMappingURL=protocol.spec.js.map