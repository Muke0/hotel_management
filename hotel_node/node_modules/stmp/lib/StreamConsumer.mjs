/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-30 21:55:29
 *
 * TODO: limit pending message size for avoiding memory bomb
 */
import { isExchangeMessage, isFollowMessage, } from './messages';
import { readVarint, varintLength } from './varint';
var StreamConsumer = /** @class */ (function () {
    function StreamConsumer(maxPendingMessage, maxTotalMessageSize) {
        if (maxPendingMessage === void 0) { maxPendingMessage = 4; }
        if (maxTotalMessageSize === void 0) { maxTotalMessageSize = 1 << 24; }
        this.maxPendingMessage = maxPendingMessage;
        this.maxTotalMessageSize = maxTotalMessageSize;
        this.buf = Buffer.allocUnsafe(0);
        this.pendingMessages = Object.create(null);
        this.totalMessageSize = 0;
        this.pendingMessageCount = 0;
        this.messageLength = null;
    }
    StreamConsumer.prototype.checkVolume = function () {
        if (this.totalMessageSize > this.maxTotalMessageSize ||
            this.pendingMessageCount > this.maxPendingMessage) {
            for (var k in this.pendingMessages) {
                var m = this.pendingMessages[k];
                this.totalMessageSize -= m._bufLength;
                this.pendingMessageCount -= 1;
                this.checkVolume();
                return;
            }
        }
    };
    StreamConsumer.prototype.mergeMessage = function (message) {
        if (isExchangeMessage(message)) {
            if (message.fin) {
                return message;
            }
            if (!message.payload) {
                message.payload = Buffer.allocUnsafe(0);
            }
            if (typeof message.payload === 'string') {
                message.payload = Buffer.from(message.payload);
            }
            message._buf = [message.payload];
            message._bufLength = message.payload.length;
            this.totalMessageSize += message._bufLength;
            this.pendingMessageCount += 1;
            this.pendingMessages[message.messageId] = message;
            this.checkVolume();
            return null;
        }
        else if (isFollowMessage(message)) {
            if (!message.payload || message.payload.length === 0) {
                return null;
            }
            var host = this.pendingMessages[message.messageId];
            if (!host) {
                // TODO report error
                return null;
            }
            if (typeof message.payload === 'string') {
                message.payload = Buffer.from(message.payload);
            }
            host._buf.push(message.payload);
            if (message.fin) {
                this.totalMessageSize -= host._bufLength;
                this.pendingMessageCount -= 1;
                host.fin = true;
                host.payload = Buffer.concat(host._buf);
                delete host._bufLength;
                delete host._buf;
                delete this.pendingMessages[host.messageId];
                return host;
            }
            else {
                host._bufLength += message.payload.length;
                this.totalMessageSize += message.payload.length;
                this.checkVolume();
                return null;
            }
        }
        return message;
    };
    StreamConsumer.prototype.consumeFrame = function (data) {
        this.buf = Buffer.concat([this.buf, data]);
        if (this.messageLength === null) {
            this.messageLength = readVarint(this.buf);
        }
        if (this.messageLength === null) {
            return;
        }
        var lengthBytes = varintLength(this.messageLength);
        if (this.buf.length < this.messageLength + lengthBytes) {
            return;
        }
        var frame = this.buf.slice(lengthBytes, lengthBytes + this.messageLength);
        this.buf = this.buf.slice(lengthBytes + this.messageLength);
        this.messageLength = null;
        return frame;
    };
    return StreamConsumer;
}());
export { StreamConsumer };
//# sourceMappingURL=StreamConsumer.js.map