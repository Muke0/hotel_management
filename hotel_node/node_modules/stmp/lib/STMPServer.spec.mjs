/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-28 19:24:16
 */
import { __assign, __awaiter, __generator } from "tslib";
import http from 'http';
import { ANY, T_SECOND } from 'monofile-utilities/lib/consts';
import { sleep } from 'monofile-utilities/lib/sleep';
import net from 'net';
import { debuglog } from 'util';
import WebSocket from 'ws';
import { jsonCodec } from './codec/json';
import { msgpackCodec } from './codec/msgpack-lite';
import { createCloseMessage, createPushMessage, createRequestMessage, createResponseMessage, isExchangeMessage, isFollowMessage, WS_NORMAL_CLOSURE, } from './messages';
import { STMPEncoding } from './STMPEncoding';
import { STMPServer } from './STMPServer';
import { TCPAdaptor } from './TCPAdaptor';
import { TCPClient } from './TCPClient';
import { WebSocketAdaptor } from './WebSocketAdaptor';
import { WebSocketClient } from './WebSocketClient';
var debug = debuglog('stmp:STMPServer.spec');
function bufferMessage(message, binary) {
    if ((isExchangeMessage(message) || isFollowMessage(message)) &&
        typeof message.payload === 'string' &&
        binary) {
        return __assign(__assign({}, message), { payload: Buffer.from(message.payload) });
    }
    return message;
}
describe('STMPServer', function () {
    var disposers = [];
    beforeEach(function () {
        disposers.forEach(function (d) {
            try {
                d();
            }
            catch (e) {
                console.error('dispose error', e);
            }
        });
    });
    it('should works as expected', function () { return __awaiter(void 0, void 0, void 0, function () {
        var expects, actuals, tcpServer, httpServer, wsServer, stmpServer, invokeClient, closeClient, tcpClient, wsClient, msgpackClient;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expects = [];
                    actuals = [];
                    tcpServer = new net.Server({ allowHalfOpen: false });
                    httpServer = new http.Server();
                    wsServer = new WebSocket.Server({ server: httpServer });
                    stmpServer = new STMPServer([
                        new TCPAdaptor(tcpServer),
                        new WebSocketAdaptor(wsServer),
                    ]);
                    stmpServer.on('message', function (connection, message) {
                        actuals.push('server message', message);
                    });
                    stmpServer.use('test.echo', function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, sleep(1)];
                                case 1:
                                    _a.sent();
                                    actuals.push('server use test.echo', ctx.incoming);
                                    debug('server test.echo input %O.', ctx.input);
                                    ctx.output(ctx.input);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    stmpServer.use('test.error', function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, sleep(1)];
                                case 1:
                                    _a.sent();
                                    actuals.push('server use test.error', ctx.incoming);
                                    throw new Error('test.error');
                            }
                        });
                    }); });
                    stmpServer.use('test.push', function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, sleep(1)];
                                case 1:
                                    _a.sent();
                                    setTimeout(function () {
                                        return ctx.instance.push('test.push', ctx.incoming.payload, ctx.instance.headers);
                                    }, 100);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    tcpServer.listen(3001);
                    disposers.push(function () { return tcpServer.close(); });
                    httpServer.listen(3002);
                    disposers.push(function () { return httpServer.close(); });
                    return [4 /*yield*/, sleep(T_SECOND)];
                case 1:
                    _a.sent();
                    invokeClient = function (kind, client, codec, binary) { return __awaiter(void 0, void 0, void 0, function () {
                        var echoInput, echoRes, echoRequestMessage, errorInput, errorError, e_1, errorRequestMessage, errorResponseMessage, pushInput, pushPushMessage, pushReceiveMessage;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    client.on('message', function (message) {
                                        actuals.push('client message', kind, message);
                                    });
                                    client.on('connecting', function (event) {
                                        actuals.push('client connecting', kind, event);
                                    });
                                    client.on('connected', function (event) {
                                        actuals.push('client connected', kind, event);
                                    });
                                    client.on('closed', function (event) {
                                        actuals.push('client closed', kind, event);
                                    });
                                    client.use('test.push', function (ctx) {
                                        actuals.push('client push', kind, ctx.incoming);
                                    });
                                    return [4 /*yield*/, client.connect()];
                                case 1:
                                    _a.sent();
                                    debug('%s client connected.', kind);
                                    expects.push('client connecting', kind, {
                                        retryCount: 0,
                                        remainCount: client.maxRetryCount,
                                        previousStatus: null,
                                        previousMessage: null,
                                    });
                                    expects.push('client connected', kind, {
                                        status: 200,
                                        message: 'OK',
                                    });
                                    echoInput = { hello: 'world' };
                                    return [4 /*yield*/, client.fetch('test.echo', echoInput)];
                                case 2:
                                    echoRes = _a.sent();
                                    echoRequestMessage = bufferMessage(createRequestMessage(1, 'test.echo', codec.encode(echoInput)), binary);
                                    actuals.push('client test.echo response', kind, echoRes.data);
                                    expects.push('server message', echoRequestMessage);
                                    expects.push('server use test.echo', echoRequestMessage);
                                    expects.push('client message', kind, bufferMessage(createResponseMessage(1, 200, codec.encode(echoInput)), binary));
                                    expects.push('client test.echo response', kind, echoInput);
                                    errorInput = { error: 'test' };
                                    errorError = ANY;
                                    _a.label = 3;
                                case 3:
                                    _a.trys.push([3, 5, , 6]);
                                    return [4 /*yield*/, client.fetch('test.error', errorInput)];
                                case 4:
                                    _a.sent();
                                    return [3 /*break*/, 6];
                                case 5:
                                    e_1 = _a.sent();
                                    errorError = e_1;
                                    return [3 /*break*/, 6];
                                case 6:
                                    errorRequestMessage = bufferMessage(createRequestMessage(2, 'test.error', codec.encode(errorInput)), binary);
                                    actuals.push('client test.error error', errorError.res);
                                    expects.push('server message', errorRequestMessage);
                                    expects.push('server use test.error', errorRequestMessage);
                                    errorResponseMessage = bufferMessage(createResponseMessage(2, 500, 'Internal Server Error', {
                                        'content-type': 'text/plain',
                                    }), binary);
                                    expects.push('client message', kind, errorResponseMessage);
                                    expects.push('client test.error error', errorResponseMessage);
                                    pushInput = { hello: 'world' };
                                    client.push('test.push', pushInput);
                                    pushPushMessage = bufferMessage(createPushMessage(3, 'test.push', codec.encode(pushInput)), binary);
                                    expects.push('server message', pushPushMessage);
                                    pushReceiveMessage = bufferMessage(createPushMessage(1, 'test.push', codec.encode(pushInput)), binary);
                                    expects.push('client message', kind, pushReceiveMessage);
                                    expects.push('client push', kind, pushReceiveMessage);
                                    return [4 /*yield*/, sleep(200)];
                                case 7:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); };
                    closeClient = function (kind, client) { return __awaiter(void 0, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            debug('close client kind: %s.', kind);
                            client.close(WS_NORMAL_CLOSURE, 'Normal Closure');
                            expects.push('client closed', kind, createCloseMessage(WS_NORMAL_CLOSURE, 'Normal Closure'));
                            return [2 /*return*/];
                        });
                    }); };
                    tcpClient = new TCPClient('127.0.0.1', 3001, '/');
                    wsClient = new WebSocketClient('ws://127.0.0.1:3002/');
                    return [4 /*yield*/, invokeClient('tcp', tcpClient, jsonCodec, true)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, invokeClient('ws', wsClient, jsonCodec, false)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, closeClient('tcp', tcpClient)];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, closeClient('ws', wsClient)];
                case 5:
                    _a.sent();
                    STMPEncoding.register(msgpackCodec);
                    msgpackClient = new TCPClient('127.0.0.1', 3001, '/', {
                        'content-type': msgpackCodec.contentType[0],
                    });
                    return [4 /*yield*/, invokeClient('msgpack', msgpackClient, msgpackCodec, true)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, closeClient('msgpack', msgpackClient)];
                case 7:
                    _a.sent();
                    expect(actuals).toEqual(expects);
                    expect(stmpServer.connections.size).toBe(0);
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=STMPServer.spec.js.map