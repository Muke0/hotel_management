"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const net_1 = tslib_1.__importDefault(require("net"));
const util_1 = require("util");
const messages_1 = require("./messages");
const protocol_1 = require("./protocol");
const STMPClient_1 = require("./STMPClient");
const StreamConsumer_1 = require("./StreamConsumer");
const types_1 = require("./types");
const utils_1 = require("./utils");
const debug = util_1.debuglog('stmp:TCPClient');
class TCPClient extends STMPClient_1.STMPClient {
    constructor(host, port, url, headers = messages_1.Headers(), options) {
        super(headers, options);
        this.handleMessageData = (data) => {
            const frame = this.consumer.consumeFrame(data);
            if (!frame) {
                return;
            }
            let message = protocol_1.parseBinary(frame);
            if (!message) {
                this.close(messages_1.WS_PROTOCOL_ERROR, 'Protocol Error');
                return;
            }
            message = this.consumer.mergeMessage(message);
            if (message === null) {
                return;
            }
            this.processMessage(message);
        };
        this.host = host;
        this.port = port;
        this.url = url || '/';
        this.consumer = new StreamConsumer_1.StreamConsumer();
    }
    connect(remainCount = this.maxRetryCount, previousStatus = null, previousMessage = null) {
        if (this.readyState !== 'closed') {
            return Promise.reject(new Error(`cannot connect with readyState: ${this.readyState}`));
        }
        let timeoutHandler;
        this.readyState = 'connecting';
        this.emit('connecting', {
            remainCount,
            retryCount: this.maxRetryCount - remainCount,
            previousStatus,
            previousMessage,
        });
        return new Promise((resolve, reject) => {
            const socket = (this.socket = net_1.default.createConnection(this.port, this.host));
            timeoutHandler = setTimeout(() => {
                reject(new Error('connect timeout'));
            }, this.handshakeTimeout);
            const openHandler = () => {
                socket.write(utils_1.createPrefixedBuffer(this.url + protocol_1.stringifyHeaders(this.headers)));
            };
            const handshakeHandler = (data) => {
                const header = this.consumer.consumeFrame(data);
                if (!header) {
                    return;
                }
                if (header.length < 2) {
                    reject(new Error('invalid handshake frame'));
                    return;
                }
                const status = header.readUInt16BE(0);
                const message = header.slice(2).toString('utf8');
                debug('handshake response [%s]: %s.', status, message);
                if (status > 299) {
                    reject({ status, message });
                }
                else {
                    clearTimeout(timeoutHandler);
                    socket.removeAllListeners();
                    this.readyState = 'connected';
                    this.emit('connected', { status, message });
                    socket.on('data', this.handleMessageData);
                    socket.on('error', (error) => {
                        this.emit('error', types_1.newError(types_1.STMPSource.TRANSPORT_ERROR, { error }));
                    });
                    socket.on('close', () => {
                        this.close(messages_1.WS_ABNORMAL_CLOSURE, 'Socket Closed');
                    });
                    resolve([status, message]);
                }
            };
            socket.on('connect', openHandler);
            socket.on('data', handshakeHandler);
            socket.on('error', reject);
            socket.on('close', reject);
        }).catch((reason) => {
            var _a, _b;
            clearTimeout(timeoutHandler);
            this.socket.removeAllListeners();
            this.readyState = 'closed';
            if (remainCount > 0) {
                return this.connect(remainCount - 1, (_a = reason) === null || _a === void 0 ? void 0 : _a.status, (_b = reason) === null || _b === void 0 ? void 0 : _b.message);
            }
            else {
                return Promise.reject(reason);
            }
        });
    }
    send(message) {
        if (messages_1.isCloseMessage(message) && !this.socket.writable) {
            return;
        }
        this.socket.write(utils_1.createPrefixedBuffer(protocol_1.stringifyBinary(message)));
    }
    terminate() {
        this.socket.removeAllListeners();
        this.socket.end();
    }
}
exports.TCPClient = TCPClient;
//# sourceMappingURL=TCPClient.js.map