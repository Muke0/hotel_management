/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 18:35:29
 */

import { Headers, isPayload } from './messages';
import { STMPEncoding } from './STMPEncoding';
import { STMPSendOptions } from './types';
import { writeVarint } from './varint';

export type MapMap<T extends Record<keyof any, keyof any>> = {
  forward: T;
  backward: Record<keyof any, keyof T>;
};

export function mapMap<T extends Record<keyof any, keyof any>>(
  input: T,
): MapMap<T> {
  const backward: any = {};
  for (const key in input) {
    if (input.hasOwnProperty(key)) {
      backward[input[key]] = key;
    }
  }
  return { forward: input, backward: backward };
}

export function b8(value: number, buf = Buffer.allocUnsafe(1)) {
  buf.writeUInt8(value, 0);
  return buf;
}

export function b16(value: number, buf = Buffer.allocUnsafe(2)) {
  buf.writeUInt16BE(value, 0);
  return buf;
}

export function b32(value: number, buf = Buffer.allocUnsafe(4)) {
  buf.writeUInt32BE(value, 0);
  return buf;
}

export function createBuffer(...chunks: Array<string | Buffer>) {
  return Buffer.concat(
    chunks.map((item) => {
      if (typeof item === 'string') {
        return Buffer.from(item);
      }
      return item;
    }),
  );
}

export function createPrefixedBuffer(...chunks: Array<string | Buffer>) {
  const content = createBuffer(...chunks);
  return Buffer.concat([writeVarint(content.length), content]);
}

/** @internal */
export function normalizeSendOptions<Q, S>(
  a: any,
  b: any,
  c: any,
  thisHeaders?: Headers,
): STMPSendOptions<Q, S> {
  const options: STMPSendOptions<Q> =
    typeof a === 'string'
      ? {
          action: a,
          data: b,
          headers: c,
        }
      : a;
  options.headers = options.headers || Headers();
  options.payloadRecord = options.payloadRecord || Headers();
  if (arguments.length < 4) {
    return options;
  }
  const headers = Headers();
  if (options.headers && options.headers !== thisHeaders) {
    for (const k in options.headers) {
      const key = k.toLowerCase();
      if (thisHeaders![key] !== options.headers[k]) {
        headers[k] = options.headers[k];
      }
    }
  }
  const contentType =
    options.contentType ??
    options.headers['content-type'] ??
    thisHeaders!['content-type'] ??
    'application/json';
  if (!isPayload(options.payloadRecord[contentType], false)) {
    if (isPayload(options.data)) {
      options.payloadRecord[contentType] = options.data;
    } else {
      const codec = STMPEncoding.get(contentType);
      if (!codec) {
        throw new Error(`cannot encode media "${contentType}"`);
      }
      options.payloadRecord[contentType] = codec.encodeReq(
        options.data,
        options,
      );
    }
  }
  const payload = options.payloadRecord[contentType];
  return Object.setPrototypeOf({ headers, payload }, options);
}

export function encodeString(str: string) {
  return str
    .replace(/%/g, '%25')
    .replace(/:/g, '%3A')
    .replace(/\n/g, '%0A');
}

export function decodeString(str: string) {
  return str.replace(/%([0-9a-fA-F]{2})/g, ($0, $1) => {
    switch ($1) {
      case '25':
        return '%';
      case '3A':
      case '3a':
        return ':';
      case '0A':
      case '0a':
        return '\n';
      default:
        return $0;
    }
  });
}

/** @internal */
export function normalizeHeaders(headers: Headers) {
  Object.setPrototypeOf(headers, null);
  for (const k in headers) {
    const key = k.toLowerCase();
    if (k !== key) {
      headers[key] = headers[k];
      delete headers[k];
    }
  }
  return headers;
}
