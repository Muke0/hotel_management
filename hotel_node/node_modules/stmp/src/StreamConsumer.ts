/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-30 21:55:29
 *
 * TODO: limit pending message size for avoiding memory bomb
 */

import {
  ExchangeMessage,
  isExchangeMessage,
  isFollowMessage,
  STMPMessage,
} from './messages';
import { readVarint, varintLength } from './varint';

export class StreamConsumer {
  private buf = Buffer.allocUnsafe(0);
  private pendingMessages: Record<
    number,
    Required<ExchangeMessage>
  > = Object.create(null);
  private totalMessageSize = 0;
  private pendingMessageCount = 0;
  private messageLength: number | null = null;

  constructor(
    private readonly maxPendingMessage = 4,
    private readonly maxTotalMessageSize = 1 << 24,
  ) {}

  private checkVolume() {
    if (
      this.totalMessageSize > this.maxTotalMessageSize ||
      this.pendingMessageCount > this.maxPendingMessage
    ) {
      for (const k in this.pendingMessages) {
        const m = this.pendingMessages[k];
        this.totalMessageSize -= m._bufLength;
        this.pendingMessageCount -= 1;
        this.checkVolume();
        return;
      }
    }
  }

  mergeMessage(message: STMPMessage) {
    if (isExchangeMessage(message)) {
      if (message.fin) {
        return message;
      }
      if (!message.payload) {
        message.payload = Buffer.allocUnsafe(0);
      }
      if (typeof message.payload === 'string') {
        message.payload = Buffer.from(message.payload);
      }
      message._buf = [message.payload];
      message._bufLength = message.payload.length;
      this.totalMessageSize += message._bufLength;
      this.pendingMessageCount += 1;
      this.pendingMessages[message.messageId] = message as any;
      this.checkVolume();
      return null;
    } else if (isFollowMessage(message)) {
      if (!message.payload || message.payload.length === 0) {
        return null;
      }
      const host = this.pendingMessages[message.messageId];
      if (!host) {
        // TODO report error
        return null;
      }
      if (typeof message.payload === 'string') {
        message.payload = Buffer.from(message.payload);
      }
      host._buf.push(message.payload);
      if (message.fin) {
        this.totalMessageSize -= host._bufLength;
        this.pendingMessageCount -= 1;
        host.fin = true;
        host.payload = Buffer.concat(host._buf);
        delete host._bufLength;
        delete host._buf;
        delete this.pendingMessages[host.messageId];
        return host as ExchangeMessage;
      } else {
        host._bufLength += message.payload.length;
        this.totalMessageSize += message.payload.length;
        this.checkVolume();
        return null;
      }
    }
    return message;
  }

  consumeFrame(data: Buffer) {
    this.buf = Buffer.concat([this.buf, data]);
    if (this.messageLength === null) {
      this.messageLength = readVarint(this.buf);
    }
    if (this.messageLength === null) {
      return;
    }
    const lengthBytes = varintLength(this.messageLength)!;
    if (this.buf.length < this.messageLength + lengthBytes) {
      return;
    }
    const frame = this.buf.slice(lengthBytes, lengthBytes + this.messageLength);
    this.buf = this.buf.slice(lengthBytes + this.messageLength);
    this.messageLength = null;
    return frame;
  }
}
