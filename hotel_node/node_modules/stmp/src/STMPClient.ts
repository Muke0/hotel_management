/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 *
 * TODO
 */

import { splice } from 'monofile-utilities/lib/array';
import { T_MINUTE, T_SECOND } from 'monofile-utilities/lib/consts';
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { F2 } from 'monofile-utilities/lib/types';
import { debuglog } from 'util';
import {
  createCloseMessage,
  createPushMessage,
  createRequestMessage,
  Headers,
  HTTP_INTERNAL_SERVER_ERROR,
  HTTP_NOT_FOUND,
  isCloseMessage,
  isExchangeMessage,
  isPingMessage,
  isResponseMessage,
  Payload,
  ResponseMessage,
  STMPMessage,
} from './messages';
import { STMPContext } from './STMPContext';
import { STMPEncoding } from './STMPEncoding';
import { STMPResponse } from './STMPResponse';
import {
  newError,
  STMPAction,
  STMPError,
  STMPHandler,
  STMPSendOptions,
  STMPSource,
} from './types';
import { normalizeHeaders, normalizeSendOptions } from './utils';

const debug = debuglog('stmp:STMPClient');

export interface ConnectingEvent {
  retryCount: number;
  remainCount: number;
  previousStatus: number | null;
  previousMessage: string | null;
}

export interface ConnectedEvent {
  status: number;
  message: string;
}

export interface ClosedEvent {
  status: number;
  message: string;
}

export interface STMPClientEventsMap {
  connecting: (event: ConnectingEvent) => void;
  connected: (event: ConnectedEvent) => void;
  closed: (event: ClosedEvent) => void;
  message: (message: STMPMessage) => void;
  error: (error: STMPError) => void;
  beforeHandle: (ctx: STMPContext<any, any, STMPClient>) => void;
  afterHandle: (ctx: STMPContext<any, any, STMPClient>) => void;
  response: (res: STMPResponse<any, any>) => void;
}

export interface STMPClientOptions {
  requestTimeout?: number;
  pingInterval?: number;
  pingTimeout?: number;
  autoPing?: boolean;
  handshakeTimeout?: number;
  maxRetryCount?: number;
  autoRetry?: boolean;
}

export abstract class STMPClient extends EventDispatcher<STMPClientEventsMap> {
  headers: Headers;
  readonly requestTimeout: number;
  readonly pingInterval: number;
  readonly pingTimeout: number;
  readonly autoPing: boolean;
  readonly handshakeTimeout: number;
  readonly maxRetryCount: number;
  readonly autoRetry: boolean;

  readyState: 'connecting' | 'connected' | 'closed';

  private nextId: number;
  private requests: Record<
    number,
    F2<ResponseMessage | null, STMPError | null>
  >;
  private handlers: Record<string, [STMPAction | undefined, STMPHandler[]]>;

  protected constructor(headers: Headers, options: STMPClientOptions = {}) {
    super();
    this.headers = normalizeHeaders(headers);
    headers['content-type'] = headers['content-type'] || 'application/json';
    this.requestTimeout = options.requestTimeout ?? T_MINUTE;
    this.pingInterval = options.pingInterval ?? T_MINUTE;
    this.pingTimeout = options.pingTimeout ?? 10 * T_SECOND;
    this.autoPing = options.autoPing ?? true;
    this.handshakeTimeout = options.handshakeTimeout ?? T_MINUTE;
    this.maxRetryCount = options.maxRetryCount ?? 7;
    this.autoRetry = options.autoRetry ?? true;
    this.nextId = 0;
    this.requests = Object.create(null);
    this.handlers = Object.create(null);
    this.readyState = 'closed';
  }

  protected startPing() {
    // TODO: ping
  }

  protected messageId() {
    return (this.nextId = (this.nextId + 1) & 0xffff);
  }

  push<Q>(action: string, body?: Payload | Q, headers?: Headers): void;
  push<Q>(options: STMPSendOptions<Q, any>): void;
  push<Q>(a: any, b?: any, c?: any) {
    const options = normalizeSendOptions(a, b, c, this.headers);
    this.send(
      createPushMessage(
        this.messageId(),
        options.action,
        options.payload,
        options.headers,
      ),
    );
  }

  fetch<Q, S>(
    action: string,
    body?: Payload | Q,
    headers?: Headers,
  ): Promise<STMPResponse<S>>;
  fetch<Q, S>(options: STMPSendOptions<Q, S>): Promise<STMPResponse<S>>;
  fetch<Q, S>(a: any, b?: any, c?: any): Promise<STMPResponse<S>> {
    const req = normalizeSendOptions<Q, S>(a, b, c, this.headers);
    const message = createRequestMessage(
      this.messageId(),
      req.action,
      req.payload,
      req.headers,
    );
    return new Promise<STMPResponse<S>>((resolve, reject) => {
      this.send(message);
      let timeoutHandler = setTimeout(() => {
        delete this.requests[message.messageId];
        reject(newError(STMPSource.REQUEST_TIMEOUT, { req }));
      }, this.requestTimeout);
      this.requests[message.messageId] = (res, error) => {
        clearTimeout(timeoutHandler);
        delete this.requests[message.messageId];
        if (!res) {
          reject(error);
          return;
        }
        const response = new STMPResponse(this, req, res);
        this.emit('response', response);
        if (res.payload) {
          const codec = STMPEncoding.get(response.get('content-type'));
          if (codec) {
            try {
              response.data = codec.decodeRes(res.payload, response);
            } catch (e) {
              reject(
                newError(STMPSource.PARSE_RESPONSE_ERROR, {
                  req,
                  res,
                  error: e,
                }),
              );
              return;
            }
          }
        }
        if (res.status > 299) {
          reject(newError(STMPSource.STATUS_NOT_OK, { req, res }));
        } else {
          resolve(response);
        }
      };
    });
  }

  close(status: number, message: string) {
    if (this.readyState !== 'connected') {
      return;
    }
    for (const k in this.requests) {
      this.requests[k](
        null,
        newError(STMPSource.CONNECTION_CLOSED, {
          close: createCloseMessage(status, message),
        }),
      );
    }
    this.readyState = 'closed';
    const close = createCloseMessage(status, message);
    this.send(close);
    this.terminate();
    this.emit('closed', close);
  }

  protected async processMessage(message: STMPMessage) {
    debug('receive message %O.', message);
    this.emit('message', message);
    if (isCloseMessage(message)) {
      this.close(message.status, message.message);
    } else if (isPingMessage(message)) {
      // TODO: validate ping status
    } else if (isResponseMessage(message)) {
      this.requests[message.messageId]?.(message, null);
    } else if (isExchangeMessage(message)) {
      const ctx = new STMPContext<any, any, STMPClient>(message, this);
      const handlers = this.handlers[message.action];
      if (!handlers) {
        ctx.output('Not Found', HTTP_NOT_FOUND);
      }
      this.emit('beforeHandle', ctx);
      if (handlers) {
        try {
          const codec = STMPEncoding.get(ctx.get('content-type'));
          ctx.action = handlers[0]!;
          if (codec && ctx.incoming.payload) {
            codec.decodeReq(ctx.incoming.payload, ctx);
          }
          for (const h of handlers[1]) {
            await h(ctx);
          }
        } catch (error) {
          ctx.output('Internal Server Error', HTTP_INTERNAL_SERVER_ERROR);
          this.emit(
            'error',
            newError(STMPSource.HANDLE_REQUEST, { error, ctx }),
          );
        }
      }
      this.emit('afterHandle', ctx);
    }
  }

  protected abstract terminate(): void;

  abstract connect(): Promise<[number, string]>;

  abstract send(message: STMPMessage): void;

  use<Q, S>(
    action: string,
    handler: STMPHandler<Q, S>,
    options?: STMPAction<Q, S>,
  ) {
    const handlers = this.handlers[action];
    if (handlers) {
      handlers[0] = options;
      handlers[1].push(handler);
    } else {
      this.handlers[action] = [options, [handler]];
    }
  }

  drop<Q, S>(action: string, handler?: STMPHandler<Q, S>) {
    const handlers = this.handlers[action];
    if (handlers) {
      splice(handlers[1], handler);
      if (handlers[1].length === 0) {
        delete this.handlers[action];
      }
    }
  }
}
