/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:10:27
 */

import { noop } from 'monofile-utilities/lib/consts';
import { EventDispatcher } from 'monofile-utilities/lib/EventDispatcher';
import { P } from 'monofile-utilities/lib/types';
import { debuglog } from 'util';
import {
  Headers,
  HTTP_INTERNAL_SERVER_ERROR,
  HTTP_NOT_FOUND,
  isIncomeMessage,
  Payload,
  STMPMessage,
} from './messages';
import { STMPConnection } from './STMPConnection';
import { STMPContext } from './STMPContext';
import { STMPEncoding } from './STMPEncoding';
import {
  newError,
  STMPAction,
  STMPError,
  STMPHandler,
  STMPSendOptions,
  STMPSource,
} from './types';
import { normalizeSendOptions } from './utils';

// @ts-ignore
const debug = debuglog('stmp:STMPServer');

export interface STMPServerEventsMap {
  /**
   * client connected, and handshake done
   */
  connection: (conn: STMPConnection) => void;
  /**
   * receive client message, which means Close message is always from client
   */
  message: (conn: STMPConnection, message: STMPMessage) => void;

  beforeHandle: (ctx: STMPContext) => P<void>;
  afterHandle: (ctx: STMPContext) => void;

  /**
   * when send Close message or receive client close message
   */
  close: (conn: STMPConnection, status: number, message: string) => void;

  error: (error: STMPError) => void;
}

export interface STMPServerOptions {
  defaultContentType?: string;
}

export interface STMPServerAdaptor {
  attach(server: STMPServer): void;
}

export type ConnFilter = (conn: STMPConnection) => boolean;

export class STMPServer extends EventDispatcher<STMPServerEventsMap>
  implements Required<Readonly<STMPServerOptions>> {
  readonly connections: Set<STMPConnection>;
  readonly groups: Map<string, Set<STMPConnection>>;
  readonly handlers: Map<
    string,
    [STMPAction | undefined, STMPHandler<any, any, STMPConnection>]
  >;
  readonly authenticate: (connection: STMPConnection) => P<void>;
  readonly defaultContentType: string;

  constructor(
    adaptors: STMPServerAdaptor[],
    authenticate: (connection: STMPConnection) => P<void> = noop,
    options: STMPServerOptions = {},
  ) {
    super();
    this.authenticate = authenticate;
    this.connections = new Set();
    this.groups = new Map();
    this.handlers = new Map();
    this.defaultContentType = options.defaultContentType ?? 'application/json';
    adaptors.forEach((adaptor) => adaptor.attach(this));
  }

  /** @internal */
  async processMessage(connection: STMPConnection, message: STMPMessage) {
    this.emit('message', connection, message);
    if (!isIncomeMessage(message)) {
      return;
    }
    const handler = this.handlers.get(message.action);
    const ctx = new STMPContext<object, object, STMPConnection>(
      message,
      connection,
    );
    try {
      await this.emitSerial('beforeHandle', ctx);
      if (ctx.isFinished()) {
        this.emit('afterHandle', ctx);
        return;
      }
      if (!handler) {
        ctx.text('Not Found', HTTP_NOT_FOUND);
        this.emit('afterHandle', ctx);
        return;
      }
      if (ctx.input === void 0 && ctx.incoming.payload) {
        const codec = STMPEncoding.get(ctx.get('content-type'));
        if (codec) {
          ctx.input = codec.decodeReq(ctx.incoming.payload, ctx);
        }
      }
      await handler[1](ctx);
    } catch (error) {
      if (!ctx.isFinished()) {
        ctx.text('Internal Server Error', HTTP_INTERNAL_SERVER_ERROR);
      }
      debug('handle %s, internal server error: %s.', message.action, error);
      this.emit('error', newError(STMPSource.HANDLE_REQUEST, { error, ctx }));
    }
    await this.emitSerial('afterHandle', ctx);
    if (!ctx.isFinished()) {
      ctx.text('Not Found', HTTP_NOT_FOUND);
    }
  }

  use<Q, S>(
    action: string,
    handler: STMPHandler<Q, S, STMPConnection>,
    options?: STMPAction<Q, S>,
  ) {
    this.handlers.set(action, [options, handler]);
  }

  broadcast<Q>(
    action: string,
    data?: Q | Payload,
    headers?: Headers,
    filer?: ConnFilter,
  ): void;
  broadcast<Q>(options: STMPSendOptions<Q, any>, filter?: ConnFilter): void;
  broadcast<Q>(a?: any, b?: any, c?: any, d?: any) {
    const options: STMPSendOptions<Q, any> =
      typeof a === 'string'
        ? {
            action: a,
            data: b,
            headers: c,
          }
        : a;
    const filter: ConnFilter | undefined = typeof a === 'string' ? d : b;
    if (filter) {
      this.connections.forEach((c) => filter!(c) && c.push(options));
    } else {
      this.connections.forEach((c) => c.push(options));
    }
  }

  pushGroup<Q>(
    groupId: string,
    action: string,
    data?: Payload | Q,
    headers?: Headers,
    filter?: ConnFilter,
  ): void;
  pushGroup<Q>(
    groupId: string,
    options: STMPSendOptions<Q, any>,
    filter?: ConnFilter,
  ): void;
  pushGroup<Q>(groupId: string, a: any, b?: any, c?: any, d?: any) {
    const options = normalizeSendOptions(a, b, c);
    const filter: ConnFilter | undefined = typeof a === 'string' ? d : b;
    if (filter) {
      this.groups.get(groupId)?.forEach((c) => filter(c) && c.push(options));
    } else {
      this.groups.get(groupId)?.forEach((c) => c.push(options));
    }
  }

  closeGroup(groupId: string, status?: number, message?: string) {
    this.groups.get(groupId)?.forEach((conn) => conn.close(status, message));
  }

  fireGroup(groupId: string) {
    this.groups.get(groupId)?.forEach((conn) => conn.leaveGroup(groupId));
  }
}
