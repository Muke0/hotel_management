/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-28 19:24:16
 */

import http from 'http';
import { ANY, T_SECOND } from 'monofile-utilities/lib/consts';
import { sleep } from 'monofile-utilities/lib/sleep';
import { F0 } from 'monofile-utilities/lib/types';
import net from 'net';
import { debuglog } from 'util';
import WebSocket from 'ws';
import { ArbitraryCodec } from './codec/arbitrary';
import { jsonCodec } from './codec/json';
import { msgpackCodec } from './codec/msgpack-lite';
import {
  createCloseMessage,
  createPushMessage,
  createRequestMessage,
  createResponseMessage,
  isExchangeMessage,
  isFollowMessage,
  STMPMessage,
  WS_NORMAL_CLOSURE,
} from './messages';
import { ConnectedEvent, ConnectingEvent, STMPClient } from './STMPClient';
import { STMPEncoding } from './STMPEncoding';
import { STMPServer } from './STMPServer';
import { TCPAdaptor } from './TCPAdaptor';
import { TCPClient } from './TCPClient';
import { STMPError } from './types';
import { WebSocketAdaptor } from './WebSocketAdaptor';
import { WebSocketClient } from './WebSocketClient';

const debug = debuglog('stmp:STMPServer.spec');

function bufferMessage(message: STMPMessage, binary: boolean) {
  if (
    (isExchangeMessage(message) || isFollowMessage(message)) &&
    typeof message.payload === 'string' &&
    binary
  ) {
    return {
      ...message,
      payload: Buffer.from(message.payload),
    };
  }
  return message;
}

describe('STMPServer', () => {
  const disposers: F0[] = [];
  beforeEach(() => {
    disposers.forEach((d) => {
      try {
        d();
      } catch (e) {
        console.error('dispose error', e);
      }
    });
  });
  it('should works as expected', async () => {
    const expects: any[] = [];
    const actuals: any[] = [];
    const tcpServer = new net.Server({ allowHalfOpen: false });
    const httpServer = new http.Server();
    const wsServer = new WebSocket.Server({ server: httpServer });
    const stmpServer = new STMPServer([
      new TCPAdaptor(tcpServer),
      new WebSocketAdaptor(wsServer),
    ]);
    stmpServer.on('message', (connection, message) => {
      actuals.push('server message', message);
    });
    stmpServer.use('test.echo', async (ctx) => {
      await sleep(1);
      actuals.push('server use test.echo', ctx.incoming);
      debug('server test.echo input %O.', ctx.input);
      ctx.output(ctx.input);
    });
    stmpServer.use('test.error', async (ctx) => {
      await sleep(1);
      actuals.push('server use test.error', ctx.incoming);
      throw new Error('test.error');
    });
    stmpServer.use('test.push', async (ctx) => {
      await sleep(1);
      setTimeout(
        () =>
          ctx.instance.push(
            'test.push',
            ctx.incoming.payload,
            ctx.instance.headers,
          ),
        100,
      );
    });
    tcpServer.listen(3001);
    disposers.push(() => tcpServer.close());
    httpServer.listen(3002);
    disposers.push(() => httpServer.close());
    await sleep(T_SECOND);
    const invokeClient = async (
      kind: string,
      client: STMPClient,
      codec: ArbitraryCodec,
      binary: boolean,
    ) => {
      client.on('message', (message) => {
        actuals.push('client message', kind, message);
      });
      client.on('connecting', (event) => {
        actuals.push('client connecting', kind, event);
      });
      client.on('connected', (event) => {
        actuals.push('client connected', kind, event);
      });
      client.on('closed', (event) => {
        actuals.push('client closed', kind, event);
      });
      client.use('test.push', (ctx) => {
        actuals.push('client push', kind, ctx.incoming);
      });
      await client.connect();
      debug('%s client connected.', kind);
      expects.push('client connecting', kind, {
        retryCount: 0,
        remainCount: client.maxRetryCount,
        previousStatus: null,
        previousMessage: null,
      } as ConnectingEvent);
      expects.push('client connected', kind, {
        status: 200,
        message: 'OK',
      } as ConnectedEvent);
      const echoInput = { hello: 'world' };
      const echoRes = await client.fetch('test.echo', echoInput);
      const echoRequestMessage = bufferMessage(
        createRequestMessage(1, 'test.echo', codec.encode(echoInput)),
        binary,
      );
      actuals.push('client test.echo response', kind, echoRes.data);
      expects.push('server message', echoRequestMessage);
      expects.push('server use test.echo', echoRequestMessage);
      expects.push(
        'client message',
        kind,
        bufferMessage(
          createResponseMessage(1, 200, codec.encode(echoInput)),
          binary,
        ),
      );
      expects.push('client test.echo response', kind, echoInput);
      const errorInput = { error: 'test' };
      let errorError: STMPError = ANY;
      try {
        await client.fetch('test.error', errorInput);
      } catch (e) {
        errorError = e;
      }
      const errorRequestMessage = bufferMessage(
        createRequestMessage(2, 'test.error', codec.encode(errorInput)),
        binary,
      );
      actuals.push('client test.error error', errorError.res);
      expects.push('server message', errorRequestMessage);
      expects.push('server use test.error', errorRequestMessage);
      const errorResponseMessage = bufferMessage(
        createResponseMessage(2, 500, 'Internal Server Error', {
          'content-type': 'text/plain',
        }),
        binary,
      );
      expects.push('client message', kind, errorResponseMessage);
      expects.push('client test.error error', errorResponseMessage);
      const pushInput = { hello: 'world' };
      client.push('test.push', pushInput);
      const pushPushMessage = bufferMessage(
        createPushMessage(3, 'test.push', codec.encode(pushInput)),
        binary,
      );
      expects.push('server message', pushPushMessage);
      const pushReceiveMessage = bufferMessage(
        createPushMessage(1, 'test.push', codec.encode(pushInput)),
        binary,
      );
      expects.push('client message', kind, pushReceiveMessage);
      expects.push('client push', kind, pushReceiveMessage);
      await sleep(200);
    };
    const closeClient = async (kind: string, client: STMPClient) => {
      debug('close client kind: %s.', kind);
      client.close(WS_NORMAL_CLOSURE, 'Normal Closure');
      expects.push(
        'client closed',
        kind,
        createCloseMessage(WS_NORMAL_CLOSURE, 'Normal Closure'),
      );
    };
    const tcpClient = new TCPClient('127.0.0.1', 3001, '/');
    const wsClient = new WebSocketClient('ws://127.0.0.1:3002/');
    await invokeClient('tcp', tcpClient, jsonCodec, true);
    await invokeClient('ws', wsClient, jsonCodec, false);
    await closeClient('tcp', tcpClient);
    await closeClient('ws', wsClient);
    STMPEncoding.register(msgpackCodec);
    const msgpackClient = new TCPClient('127.0.0.1', 3001, '/', {
      'content-type': msgpackCodec.contentType[0],
    });
    await invokeClient('msgpack', msgpackClient, msgpackCodec, true);
    await closeClient('msgpack', msgpackClient);
    expect(actuals).toEqual(expects);
    expect(stmpServer.connections.size).toBe(0);
  });
});
