/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-12-18 11:38:40
 */

import { ArbitraryCodec, CodecBase, isArbitraryCodec } from './codec/arbitrary';
import { jsonCodec } from './codec/json';
import { Payload } from './messages';
import { STMPContext } from './STMPContext';
import { STMPResponse } from './STMPResponse';
import { STMPSendOptions } from './types';

export interface STMPCodec extends CodecBase {
  encodeReq<Q>(data: Q, options: STMPSendOptions<Q>): Payload;
  encodeRes<S, Q>(data: S, ctx: STMPContext<Q, S>): Payload;
  decodeReq<Q>(payload: NonNullable<Payload>, ctx: STMPContext<Q>): Q;
  decodeRes<S, Q>(payload: NonNullable<Payload>, res: STMPResponse<S, Q>): S;
}

function normalizeCodec(c: STMPCodec | ArbitraryCodec): STMPCodec {
  if (isArbitraryCodec(c)) {
    return Object.assign(c, {
      encodeReq: c.encode,
      encodeRes: c.encode,
      decodeReq: c.decode,
      decodeRes: c.decode,
    });
  }
  return c;
}

export class STMPEncoding {
  static codecs: Record<string, STMPCodec> = {};

  static register(...codecs: Array<STMPCodec | ArbitraryCodec>) {
    for (const c of codecs) {
      const ac = normalizeCodec(c);
      for (const t of c.contentType) {
        this.codecs[t] = ac;
      }
    }
  }

  static get(contentType: string | undefined): STMPCodec | undefined {
    return contentType ? this.codecs[contentType] : void 0;
  }
}

STMPEncoding.register(jsonCodec);
