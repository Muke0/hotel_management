/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 18:28:54
 */

import { IncomingHttpHeaders, IncomingMessage } from 'http';
import { debuglog } from 'util';
import WebSocket from 'ws';
import {
  createCloseMessage,
  Headers,
  HTTP_OK,
  isCloseMessage,
  isExchangeMessage,
  STMPMessage,
  WS_PROTOCOL_ERROR,
} from './messages';
import {
  parseBinary,
  parseText,
  stringifyBinary,
  stringifyText,
} from './protocol';
import { STMPConnection } from './STMPConnection';
import { STMPServer } from './STMPServer';
import { STMPInstance } from './types';

const debug = debuglog('stmp:WebSocketConnection');

function normalizeHeaders(httpHeaders: IncomingHttpHeaders) {
  const headers = Headers();
  Object.keys(httpHeaders).forEach((k) => {
    const v = httpHeaders[k];
    headers[k] = (Array.isArray(v) ? v[v.length - 1] : v) || '';
  });
  return headers;
}

export class WebSocketConnection extends STMPConnection
  implements STMPInstance {
  readonly ws: WebSocket;
  readonly request: IncomingMessage;

  constructor(server: STMPServer, ws: WebSocket, request: IncomingMessage) {
    super(server, request.socket);
    this.request = request;
    this.ws = ws;
    debug('handshake frame: %s %O.', request.url, request.headers);
    this.init(request.url || '', normalizeHeaders(request.headers));
    Object.assign(this.headers, this.query.__stmp_headers__);
    this.authenticate().then(() => {
      if (this.handshakeStatus === HTTP_OK) {
        ws.on('message', this.handleMessage);
        ws.on('close', this.handleClose);
      }
    });
  }

  private handleClose = (code: number, reason: string) => {
    this.processMessage(createCloseMessage(code, reason));
  };

  private handleMessage = (data: WebSocket.Data) => {
    let message: STMPMessage | null;
    if (typeof data === 'string') {
      message = parseText(data);
    } else if (Array.isArray(data)) {
      message = parseBinary(Buffer.concat(data));
    } else if (!Buffer.isBuffer(data)) {
      message = parseBinary(Buffer.from(data));
    } else {
      message = parseBinary(data);
    }
    debug('receive message %s as %O.', data, message);
    if (!message) {
      this.close(WS_PROTOCOL_ERROR);
      return;
    }
    this.processMessage(message);
  };

  send(message: STMPMessage): void {
    if (isCloseMessage(message)) {
      this.ws.close(message.status, message.message);
      return;
    }
    if (isExchangeMessage(message) && message.payload instanceof Uint8Array) {
      this.ws.send(stringifyBinary(message));
    } else {
      this.ws.send(stringifyText(message));
    }
  }

  protected sendHandshake(status: number, message: string): void {
    this.ws.send(message ? status + '\n' + message : status + '');
  }

  protected terminate(): void {
    this.ws.removeAllListeners();
  }
}
