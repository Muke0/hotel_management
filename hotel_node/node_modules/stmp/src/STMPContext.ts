/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 16:49:10
 *
 * TODO
 */

import {
  createResponseMessage,
  HTTP_OK,
  IncomeMessage,
  isPayload,
  isRequestMessage,
  Payload,
  ResponseMessage,
} from './messages';
import { STMPEncoding } from './STMPEncoding';
import { STMPAction, STMPInstance } from './types';

export interface STMPContext<
  Q = any,
  S = any,
  I extends STMPInstance = STMPInstance
> extends stmp.Context<Q, S> {}

export class STMPContext<
  Q = any,
  S = any,
  I extends STMPInstance = STMPInstance
> {
  readonly instance: I;
  readonly incoming: IncomeMessage;
  readonly outgoing: ResponseMessage;

  input!: Readonly<Q>;
  action!: STMPAction<Q, S>;

  constructor(message: IncomeMessage, instance: I) {
    this.instance = instance;
    this.incoming = message;
    this.outgoing = createResponseMessage(message.messageId, 0, '');
  }

  isFinished() {
    return this.outgoing.status > 0;
  }

  get(key: string): string | undefined {
    return this.incoming.headers[key] ?? this.instance.headers[key];
  }

  sget(key: string): string | undefined {
    return this.outgoing.headers[key] ?? this.instance.headers[key];
  }

  set(key: string, value: string) {
    key = key.toLowerCase();
    if (this.instance.headers[key] !== value) {
      this.outgoing.headers[key] = value;
    }
    return this;
  }

  send() {
    if (isRequestMessage(this.incoming)) {
      this.instance.send(this.outgoing);
    }
  }

  json(data: S, status = HTTP_OK) {
    this.output(data, status, 'application/json');
  }

  text(text: string, status = HTTP_OK) {
    this.output(text, status, 'text/plain');
  }

  raw(text: Uint8Array, status = HTTP_OK) {
    this.output(text, status, 'application/octet-stream');
  }

  output(payload: S | Payload, status = HTTP_OK, contentType?: string) {
    contentType = contentType ?? this.sget('content-type')!;
    if (!isPayload(payload)) {
      const codec = STMPEncoding.get(contentType);
      if (!codec) {
        throw new TypeError(
          `cannot find codec for content type "${contentType}"`,
        );
      }
      payload = codec.encodeRes(payload, this);
    }
    this.set('content-type', contentType);
    this.outgoing.payload = payload;
    this.outgoing.status = status;
    this.send();
  }
}
