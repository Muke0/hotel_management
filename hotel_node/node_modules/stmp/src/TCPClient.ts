/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 */

import net from 'net';
import { debuglog } from 'util';
import {
  Headers,
  isCloseMessage,
  STMPMessage,
  WS_ABNORMAL_CLOSURE,
  WS_PROTOCOL_ERROR,
} from './messages';
import { parseBinary, stringifyBinary, stringifyHeaders } from './protocol';
import { STMPClient, STMPClientOptions } from './STMPClient';
import { StreamConsumer } from './StreamConsumer';
import { newError, STMPInstance, STMPSource } from './types';
import { createPrefixedBuffer } from './utils';

const debug = debuglog('stmp:TCPClient');

export class TCPClient extends STMPClient implements STMPInstance {
  readonly host: string;
  readonly port: number;
  readonly url: string;
  readonly consumer: StreamConsumer;
  socket!: net.Socket;

  constructor(
    host: string,
    port: number,
    url?: string,
    headers = Headers(),
    options?: STMPClientOptions,
  ) {
    super(headers, options);
    this.host = host;
    this.port = port;
    this.url = url || '/';
    this.consumer = new StreamConsumer();
  }

  private handleMessageData = (data: Buffer) => {
    const frame = this.consumer.consumeFrame(data);
    if (!frame) {
      return;
    }
    let message = parseBinary(frame);
    if (!message) {
      this.close(WS_PROTOCOL_ERROR, 'Protocol Error');
      return;
    }
    message = this.consumer.mergeMessage(message);
    if (message === null) {
      return;
    }
    this.processMessage(message);
  };

  connect(
    remainCount = this.maxRetryCount,
    previousStatus: number | null = null,
    previousMessage: string | null = null,
  ): Promise<[number, string]> {
    if (this.readyState !== 'closed') {
      return Promise.reject(
        new Error(`cannot connect with readyState: ${this.readyState}`),
      );
    }
    let timeoutHandler: any;
    this.readyState = 'connecting';
    this.emit('connecting', {
      remainCount,
      retryCount: this.maxRetryCount - remainCount,
      previousStatus,
      previousMessage,
    });
    return new Promise<[number, string]>((resolve, reject) => {
      const socket = (this.socket = net.createConnection(this.port, this.host));
      timeoutHandler = setTimeout(() => {
        reject(new Error('connect timeout'));
      }, this.handshakeTimeout);
      const openHandler = () => {
        socket.write(
          createPrefixedBuffer(this.url + stringifyHeaders(this.headers)),
        );
      };
      const handshakeHandler = (data: Buffer) => {
        const header = this.consumer.consumeFrame(data);
        if (!header) {
          return;
        }
        if (header.length < 2) {
          reject(new Error('invalid handshake frame'));
          return;
        }
        const status = header.readUInt16BE(0);
        const message = header.slice(2).toString('utf8');
        debug('handshake response [%s]: %s.', status, message);
        if (status > 299) {
          reject({ status, message });
        } else {
          clearTimeout(timeoutHandler);
          socket.removeAllListeners();
          this.readyState = 'connected';
          this.emit('connected', { status, message });
          socket.on('data', this.handleMessageData);
          socket.on('error', (error) => {
            this.emit('error', newError(STMPSource.TRANSPORT_ERROR, { error }));
          });
          socket.on('close', () => {
            this.close(WS_ABNORMAL_CLOSURE, 'Socket Closed');
          });
          resolve([status, message]);
        }
      };
      socket.on('connect', openHandler);
      socket.on('data', handshakeHandler);
      socket.on('error', reject);
      socket.on('close', reject);
    }).catch((reason) => {
      clearTimeout(timeoutHandler);
      this.socket.removeAllListeners();
      this.readyState = 'closed';
      if (remainCount > 0) {
        return this.connect(remainCount - 1, reason?.status, reason?.message);
      } else {
        return Promise.reject(reason);
      }
    });
  }

  send(message: STMPMessage): void {
    if (isCloseMessage(message) && !this.socket.writable) {
      return;
    }
    this.socket.write(createPrefixedBuffer(stringifyBinary(message)));
  }

  protected terminate(): void {
    this.socket.removeAllListeners();
    this.socket.end();
  }
}
