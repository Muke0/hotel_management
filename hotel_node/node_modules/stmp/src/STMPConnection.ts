/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 18:29:39
 */

import { parse } from 'monofile-utilities/lib/query-string';
import net from 'net';
import URL from 'url';
import {
  createCloseMessage,
  createPingMessage,
  createPushMessage,
  Headers,
  HTTP_INTERNAL_SERVER_ERROR,
  HTTP_OK,
  isCloseMessage,
  isPingMessage,
  isResponseMessage,
  Payload,
  STMPMessage,
  WS_NORMAL_CLOSURE,
} from './messages';
import { STMPServer } from './STMPServer';
import { STMPSendOptions } from './types';
import { normalizeSendOptions } from './utils';

export interface STMPConnection extends stmp.Connection {}

export type ExtendedQuery = {
  [P in string | number]: string | string[] | ExtendedQuery;
};

export abstract class STMPConnection {
  url: string;
  headers: Headers;
  pathname: string;
  search: string;
  query: ExtendedQuery;
  server: STMPServer;
  socket: net.Socket;
  groups: Set<string>;
  handshakeStatus: number;
  closeStatus: number;
  closeMessage: string;
  private nextId: number;

  protected constructor(server: STMPServer, socket: net.Socket) {
    this.server = server;
    this.socket = socket;
    this.groups = new Set();
    this.handshakeStatus = 0;
    this.closeStatus = 0;
    this.closeMessage = '';
    this.url = '';
    this.headers = Headers();
    this.pathname = '';
    this.search = '';
    this.query = Headers();
    this.nextId = 0;
  }

  protected init(url: string, headers: Headers) {
    this.url = url;
    headers['content-type'] =
      headers['content-type'] ?? this.server.defaultContentType;
    this.headers = headers;
    const parsedUrl = URL.parse(url);
    this.pathname = parsedUrl.pathname || '';
    this.search = parsedUrl.search || '';
    this.query = parse(parsedUrl.query || '');
  }

  protected async authenticate() {
    try {
      await this.server.authenticate(this);
      this.handshake(HTTP_OK, 'OK');
      if (this.handshakeStatus < 300) {
        this.server.emit('connection', this);
      }
    } catch (e) {
      this.handshake(HTTP_INTERNAL_SERVER_ERROR, 'Internal Server Error');
    }
  }

  private destroy(status: number, message: string) {
    this.closeStatus = status;
    this.closeMessage = message;
    this.server.connections.delete(this);
    this.groups?.forEach((groupId) => this.leaveGroup(groupId));
    this.terminate();
  }

  protected processMessage(message: STMPMessage) {
    if (isCloseMessage(message)) {
      this.destroy(message.status, message.message);
    } else if (isPingMessage(message)) {
      this.send(createPingMessage(message.messageId));
    } else if (isResponseMessage(message)) {
      // TODO: allow server request
    } else {
      this.server.processMessage(this, message);
    }
  }

  close(status = WS_NORMAL_CLOSURE, message = 'Normal Closure') {
    if (this.closeStatus > 0 || status < 1000) {
      return;
    }
    this.send(createCloseMessage(status, message));
    this.destroy(status, message);
  }

  joinGroup(groupId: string): void {
    this.groups.add(groupId);
    const group = this.server.groups.get(groupId);
    if (group) {
      group.add(this);
    } else {
      this.server.groups.set(groupId, new Set([this]));
    }
  }

  leaveGroup(groupId: string): void {
    this.groups.delete(groupId);
    this.server.groups.get(groupId)?.delete(this);
  }

  handshake(status = HTTP_OK, message = 'OK') {
    if (this.handshakeStatus > 0 || status < 100) {
      return;
    }
    this.handshakeStatus = status;
    this.sendHandshake(status, message);
  }

  messageId() {
    return (this.nextId = (this.nextId + 1) & 0xffff);
  }

  push<Q>(action: string, data?: Q | Payload, headers?: Headers): void;
  push<Q>(options: STMPSendOptions<Q, any>): void;
  push<Q>(a: any, b?: any, c?: any) {
    const options = normalizeSendOptions(a, b, c, this.headers);
    this.send(
      createPushMessage(
        this.messageId(),
        options.action,
        options.payload,
        options.headers,
      ),
    );
  }

  protected abstract terminate(): void;

  protected abstract sendHandshake(status: number, message: string): void;

  abstract send(message: STMPMessage): void;
}
