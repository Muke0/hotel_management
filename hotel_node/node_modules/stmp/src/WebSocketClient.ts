/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-27 17:01:54
 */

import { appendQuery } from 'monofile-utilities/lib/query-string';
import { debuglog } from 'util';
import {
  Headers,
  isCloseMessage,
  STMPMessage,
  WS_NORMAL_CLOSURE,
  WS_PROTOCOL_ERROR,
  WS_USER_MIN,
} from './messages';
import { parseText, stringifyText } from './protocol';
import { STMPClient, STMPClientOptions } from './STMPClient';
import { newError, STMPInstance, STMPSource } from './types';

const debug = debuglog('stmp:WebSocketClient');

export class WebSocketClient extends STMPClient implements STMPInstance {
  static WebSocket = WebSocket;
  readonly url: string;
  ws!: WebSocket;

  constructor(url: string, headers = Headers(), options?: STMPClientOptions) {
    super(headers, options);
    this.url = url;
  }

  protected terminate(): void {
    this.ws.onmessage = this.ws.onclose = this.ws.onerror = null;
  }

  connect(
    remainCount = this.maxRetryCount,
    previousStatus: number | null = null,
    previousMessage: string | null = null,
  ): Promise<[number, string]> {
    if (this.readyState !== 'closed') {
      return Promise.reject(
        new Error(`cannot connect with readyState: ${this.readyState}`),
      );
    }
    this.readyState = 'connecting';
    this.emit('connecting', {
      remainCount,
      retryCount: this.maxRetryCount - remainCount,
      previousStatus,
      previousMessage,
    });
    let timeoutHandler: any;
    return new Promise<[number, string]>((resolve, reject) => {
      const ws = (this.ws = new WebSocketClient.WebSocket(
        appendQuery(this.url, {
          __stmp_headers__: this.headers,
        }),
      ));
      timeoutHandler = setTimeout(
        () => reject(new Error('connect timeout')),
        this.handshakeTimeout,
      );
      ws.onmessage = (ev) => {
        if (typeof ev.data === 'string') {
          const newLine = ev.data.indexOf('\n');
          const status = +ev.data.substr(0, newLine > -1 ? newLine : void 0);
          const message = newLine > -1 ? ev.data.substr(newLine + 1) : '';
          debug('handshake response [%s]: %s.', status, message);
          if (status > 299) {
            reject({ status, message });
          } else {
            clearTimeout(timeoutHandler);
            this.readyState = 'connected';
            this.emit('connected', { status, message });
            this.ws.onmessage = (ev) => {
              const message = parseText(ev.data);
              debug('received raw message: %s: %O.', ev.data, message);
              if (!message) {
                this.close(WS_PROTOCOL_ERROR, 'Invalid Message');
              } else {
                this.processMessage(message);
              }
            };
            this.ws.onerror = (event) => {
              this.emit(
                'error',
                newError(STMPSource.TRANSPORT_ERROR, { event }),
              );
            };
            this.ws.onclose = (ev) => {
              this.close(ev.code, ev.reason);
            };
            resolve([status, message]);
          }
        } else {
          reject(ev);
        }
      };
      ws.onclose = ws.onerror = reject;
    }).catch((reason) => {
      clearTimeout(timeoutHandler);
      this.readyState = 'closed';
      this.ws.onmessage = this.ws.onerror = this.ws.onclose = null;
      if (remainCount > 0) {
        return this.connect(remainCount - 1, reason?.status, reason?.message);
      } else {
        return Promise.reject(reason);
      }
    });
  }

  send(message: STMPMessage): void {
    if (isCloseMessage(message)) {
      if (this.ws.readyState === this.ws.OPEN) {
        this.ws.close(
          message.status >= WS_USER_MIN ? message.status : WS_NORMAL_CLOSURE,
          message.message,
        );
      }
    } else {
      this.ws.send(stringifyText(message));
    }
  }
}
