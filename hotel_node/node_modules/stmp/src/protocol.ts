/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:35:34
 *
 * FINE
 */

import { itos, stoi } from 'monofile-utilities/lib/numberFormat';
import {
  Headers,
  isExchangeMessage,
  isFollowMessage,
  MessageKind,
  Payload,
  STMPMessage,
} from './messages';
import { decodeString, encodeString, mapMap } from './utils';

const MessageKindText = mapMap({
  [MessageKind.Ping]: 'p',
  [MessageKind.Request]: 'q',
  [MessageKind.Push]: 'n',
  [MessageKind.Response]: 's',
  [MessageKind.Follow]: 'f',
  [MessageKind.Close]: 'c',
} as const);

const MessageKindBinary = mapMap({
  [MessageKind.Ping]: 0b1000_0000,
  [MessageKind.Request]: 0b1001_0000,
  [MessageKind.Push]: 0b1010_0000,
  [MessageKind.Response]: 0b1011_0000,
  [MessageKind.Close]: 0b1100_0000,
  [MessageKind.Follow]: 0b1101_0000,
} as const);

function parseTextPayload(input: string) {
  const newLine = input.indexOf('\n');
  const newNewLine = input.indexOf('\n\n');
  const rawHeaders =
    newNewLine > newLine ? input.substring(newLine + 1, newNewLine) : '';
  const headers = parseHeaders(rawHeaders);
  const payload =
    input.substring(
      newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
        ? newLine + 1
        : input.length,
    ) || void 0;
  return { headers, payload };
}

export function parseText(input: string): STMPMessage | null {
  const kind = MessageKindText.backward[input.charAt(0)];
  if (!kind || input.length < 2) {
    return null;
  }
  switch (kind) {
    case MessageKind.Ping:
      return { kind, messageId: stoi(input.substr(1)) };
    case MessageKind.Request:
    case MessageKind.Push: {
      const space = input.indexOf(' ');
      const newLine = input.indexOf('\n', space);
      const action = decodeString(
        input.substring(space + 1, newLine > 0 ? newLine : void 0),
      );
      const { payload, headers } = parseTextPayload(input);
      return {
        kind,
        messageId: stoi(input.substring(1, space)),
        action,
        headers,
        payload,
        fin: true,
      };
    }
    case MessageKind.Response: {
      const space = input.indexOf(' ', 1);
      if (space < 0) {
        return null;
      }
      const newLine = input.indexOf('\n', space);
      const { payload, headers } = parseTextPayload(input);
      return {
        kind,
        messageId: stoi(input.substring(1, space)),
        status: +input.substring(space + 1, newLine > 0 ? newLine : void 0),
        headers,
        payload,
        fin: true,
      };
    }
    case MessageKind.Close: {
      const newLine = input.indexOf('\n', 1);
      return {
        kind,
        status: stoi(input.substring(1, newLine > 0 ? newLine : void 0)),
        message: newLine > 0 ? input.substr(newLine + 1) : '',
      };
    }
    case MessageKind.Follow: {
      const newLine = input.indexOf('\n', 1);
      if (newLine < 0 || newLine === input.length - 1) {
        return null;
      }
      const messageId = stoi(input.substring(1, newLine));
      const payload = input.substr(newLine + 1);
      return { kind, fin: true, messageId, payload };
    }
    default:
      throw new Error('unknown message kind');
  }
}

const CHAR_NEWLINE = '\n'.charCodeAt(0);
const NEW_NEW_LINE = new Uint8Array([CHAR_NEWLINE, CHAR_NEWLINE]);

function parseBinaryPayload(input: Buffer, offset: number) {
  const newLine = input.indexOf(CHAR_NEWLINE, offset);
  const newNewLine = input.indexOf(NEW_NEW_LINE, offset);
  const rawHeaders =
    newNewLine > newLine ? input.slice(newLine + 1, newNewLine) : '';
  const headers = parseHeaders(rawHeaders.toString());
  const payload =
    input.slice(
      newNewLine > -1
        ? newNewLine + 2
        : newLine > -1
        ? newLine + 1
        : input.length,
    ) || void 0;
  return { headers, payload: payload.length > 0 ? payload : void 0 };
}

export function parseBinary(input: Buffer): STMPMessage | null {
  if (input.length < 1) {
    return null;
  }
  const head = input[0];
  const kind = MessageKindBinary.backward[head & 0b11110000];
  if (!kind) {
    return null;
  }
  const fin = (head & 0b1000) !== 0;
  switch (kind) {
    case MessageKind.Ping: {
      if (input.length < 3) {
        return null;
      }
      const messageId = input.readUInt16BE(1);
      return { kind, messageId };
    }
    case MessageKind.Request:
    case MessageKind.Push: {
      if (input.length < 3) {
        return null;
      }
      const messageId = input.readUInt16BE(1);
      const newLine = input.indexOf(CHAR_NEWLINE, 3);
      const action = decodeString(
        input.slice(3, newLine < 0 ? input.length : newLine).toString(),
      );
      const { headers, payload } = parseBinaryPayload(input, 3);
      return { kind, action, payload, fin, messageId, headers };
    }
    case MessageKind.Response: {
      const messageId = input.readUInt16BE(1);
      if (input.length < 5) {
        return null;
      }
      const status = input.readUInt16BE(3);
      const { headers, payload } = parseBinaryPayload(input, 5);
      return {
        kind,
        status,
        payload,
        fin,
        messageId,
        headers,
      };
    }
    case MessageKind.Close:
      if (input.length < 3) {
        return null;
      }
      const status = input.readUInt16BE(1);
      const message = input.slice(3).toString('utf8');
      return { kind, status, message };
    case MessageKind.Follow:
      if (input.length < 4) {
        return null;
      }
      const messageId = input.readUInt16BE(1);
      const payload = input.slice(3);
      return { kind, payload, messageId, fin };
    default:
      throw new Error('unknown message kind');
  }
}

export function stringifyText(message: STMPMessage) {
  const head = MessageKindText.forward[message.kind];
  switch (message.kind) {
    case MessageKind.Close:
      return (
        head +
        itos(message.status) +
        (message.message ? '\n' + message.message : '')
      );
    case MessageKind.Response:
      return (
        head +
        itos(message.messageId) +
        ' ' +
        message.status +
        stringifyHeaders(message.headers) +
        (message.payload ? '\n\n' + message.payload : '')
      );
    case MessageKind.Push:
    case MessageKind.Request:
      return (
        head +
        itos(message.messageId) +
        ' ' +
        encodeString(message.action) +
        stringifyHeaders(message.headers) +
        (message.payload ? '\n\n' + message.payload : '')
      );
    case MessageKind.Ping:
      return head + itos(message.messageId);
    case MessageKind.Follow:
      return head + itos(message.messageId) + '\n' + message.payload;
    default:
      throw new Error('unknown message kind');
  }
}

function appendPayload(
  head: Buffer,
  headers: Headers | undefined,
  payload: Payload,
) {
  const bufHeaders = headers
    ? Buffer.from(stringifyHeaders(headers))
    : Buffer.allocUnsafe(0);
  if (!payload && !bufHeaders.length) {
    return head;
  } else if (payload instanceof Uint8Array && payload.byteLength > 0) {
    return Buffer.concat([head, bufHeaders, Buffer.from('\n\n'), payload]);
  } else if (typeof payload === 'string') {
    return Buffer.concat([
      head,
      bufHeaders,
      Buffer.from('\n\n'),
      Buffer.from(payload),
    ]);
  } else {
    return Buffer.concat([head, bufHeaders]);
  }
}

export function stringifyBinary(message: STMPMessage) {
  let first = MessageKindBinary.forward[message.kind];
  if (isExchangeMessage(message) || isFollowMessage(message)) {
    first |= message.fin ? 0b1000 : 0;
  }
  switch (message.kind) {
    case MessageKind.Ping: {
      const head = Buffer.allocUnsafe(3);
      head.writeUInt8(first, 0);
      head.writeUInt16BE(message.messageId, 1);
      return head;
    }
    case MessageKind.Request:
    case MessageKind.Push: {
      const head = Buffer.allocUnsafe(3);
      head.writeUInt8(first, 0);
      head.writeUInt16BE(message.messageId, 1);
      return appendPayload(
        Buffer.concat([head, Buffer.from(encodeString(message.action))]),
        message.headers,
        message.payload,
      );
    }
    case MessageKind.Response: {
      const head = Buffer.allocUnsafe(5);
      head.writeUInt8(first, 0);
      head.writeUInt16BE(message.messageId, 1);
      head.writeUInt16BE(message.status, 3);
      return appendPayload(head, message.headers, message.payload);
    }
    case MessageKind.Close: {
      const head = Buffer.allocUnsafe(3);
      head.writeUInt8(first, 0);
      head.writeUInt16BE(message.status, 1);
      return Buffer.concat([head, Buffer.from(message.message)]);
    }
    case MessageKind.Follow:
      const head = Buffer.allocUnsafe(3);
      head.writeUInt8(first, 0);
      head.writeUInt16BE(message.messageId, 1);
      if (!message.payload) {
        return head;
      }
      if (typeof message.payload === 'string') {
        return Buffer.concat([head, Buffer.from(message.payload)]);
      }
      return Buffer.concat([head, message.payload]);
    default:
      throw new Error('unknown message kind');
  }
}

export function parseHeaders(raw: string) {
  return raw
    .trim()
    .split('\n')
    .reduce((map, line) => {
      const sepIndex = line.indexOf(':');
      if (sepIndex === -1) {
        return map;
      }
      const name = line
        .substr(0, sepIndex)
        .trim()
        .toLowerCase();
      map[decodeString(name)] = decodeString(line.substr(sepIndex + 1).trim());
      return map;
    }, Headers());
}

export function stringifyHeaders(headers: Headers) {
  return Object.keys(headers)
    .map((name) => {
      const value = headers[name];
      return `\n${encodeString(name)}: ${encodeString(value)}`;
    })
    .join('');
}
