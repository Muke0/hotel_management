/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 15:35:44
 *
 * shared types for client & server
 * TODO
 */

import { isObject } from 'monofile-utilities/lib/is';
import { P } from 'monofile-utilities/lib/types';
import {
  CloseMessage,
  Headers,
  Payload,
  ResponseMessage,
  STMPMessage,
} from './messages';
import { STMPClient } from './STMPClient';
import { STMPConnection } from './STMPConnection';
import { STMPContext } from './STMPContext';

declare global {
  namespace stmp {
    export interface Connection {}

    export interface Context<Q, S> {}

    export interface Response<S, Q> {}

    export interface SendOptions<Q, S> {}

    export interface Action<Q, S> {}
  }
}

export type STMPHandler<
  Q = any,
  S = any,
  I extends STMPInstance = STMPInstance
> = (ctx: STMPContext<Q, S, I>) => P<void>;

export interface STMPAction<Q = any, S = any> extends stmp.Action<Q, S> {}

export interface STMPInstance {
  headers: Headers;
  send(message: STMPMessage): void;
}

export interface STMPSendOptions<Q = any, S = any>
  extends stmp.SendOptions<Q, S> {
  action: string;
  contentType?: string;
  headers?: Headers;
  data?: Q | Payload;
  /** @internal */
  payloadRecord?: Record<string, Payload>;
  /** @internal */
  payload?: Payload;
}

export enum STMPSource {
  HANDLE_REQUEST = 'HANDLE_REQUEST',
  STATUS_NOT_OK = 'STATUS_NOT_OK',
  REQUEST_TIMEOUT = 'REQUEST_TIMEOUT',
  TRANSPORT_ERROR = 'TRANSPORT_ERROR',
  CONNECTION_CLOSED = 'CONNECTION_CLOSED',
  PARSE_RESPONSE_ERROR = 'PARSE_RESPONSE_ERROR',
}

export interface STMPError extends Error {
  error: Error;
  event: Event;
  source: STMPSource;
  ctx: STMPContext;
  conn: STMPConnection;
  client: STMPClient;
  req: STMPSendOptions<any, any>;
  res: ResponseMessage;
  close: CloseMessage;
}

export function newError(
  source: STMPSource,
  options: Partial<STMPError> = {},
): STMPError {
  options.source = source;
  if (options.error instanceof Error) {
    Object.setPrototypeOf(options, options.error);
    options.name = `${options.error.name}(${source})`;
  } else {
    Object.setPrototypeOf(options, new Error(''));
    options.name = source;
  }
  return options as STMPError;
}

export function isSTMPError(error: unknown): error is STMPError {
  return isObject(error) && typeof (error as any).source === 'string';
}
