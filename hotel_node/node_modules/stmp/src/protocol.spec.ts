/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-20 20:45:47
 *
 * FINE
 */

import { itos } from 'monofile-utilities/lib/numberFormat';
import {
  createCloseMessage,
  createFollowMessage,
  createPingMessage,
  createPushMessage,
  createRequestMessage,
  createResponseMessage,
  STMPMessage,
} from './messages';
import {
  parseBinary,
  parseText,
  stringifyBinary,
  stringifyText,
} from './protocol';
import { b16, b8, createBuffer } from './utils';

interface ProtocolSpecCase {
  name: string;
  message: STMPMessage;
  text: string | null;
  binary: Buffer;
  withServerLatency?: boolean;
}

const protocolSpecCases: ProtocolSpecCase[] = [
  {
    name: 'ping',
    message: createPingMessage(0xff),
    text: 'p' + itos(0xff),
    binary: createBuffer(b8(0b1000_0000), b16(0xff)),
  },
  {
    name: 'close',
    message: createCloseMessage(1009, 'ä¸­æ–‡'),
    text: 'c' + itos(1009) + '\nä¸­æ–‡',
    binary: createBuffer(b8(0b1100_0000), b16(1009), 'ä¸­æ–‡'),
  },
  {
    name: 'request',
    message: createRequestMessage(
      0xffff,
      'room.enter',
      'Hello: ðŸ˜‚\nworld: \n\n!',
    ),
    text: 'q' + itos(0xffff) + ' room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
    binary: createBuffer(
      b8(0b1001_1000),
      b16(0xffff),
      'room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
    ),
  },
  {
    name: 'notify',
    message: createPushMessage(0xff, 'room.enter', 'Hello: ðŸ˜‚\nworld: \n\n!'),
    text: 'n' + itos(0xff) + ' room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
    binary: createBuffer(
      b8(0b1010_1000),
      b16(0xff),
      'room.enter\n\nHello: ðŸ˜‚\nworld: \n\n!',
    ),
  },
  {
    name: 'response',
    message: createResponseMessage(0xff0f, 200, 'Hello: ðŸ˜‚\nworld: \n\n!'),
    text: 's' + itos(0xff0f) + ' 200' + '\n\nHello: ðŸ˜‚\nworld: \n\n!',
    binary: createBuffer(
      b8(0b1011_1000),
      b16(0xff0f),
      b16(200),
      '\n\nHello: ðŸ˜‚\nworld: \n\n!',
    ),
  },
  {
    name: 'request header',
    message: createRequestMessage(0xff, 'echo%\n', 'Hello: ðŸ˜‚\nworld: \n\n!', {
      'key:name': 'value%:\nname',
    }),
    text:
      'q' +
      itos(0xff) +
      ' echo%25%0A\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
    binary: createBuffer(
      b8(0b1001_1000),
      b16(0xff),
      'echo%25%0A\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
    ),
  },
  {
    name: 'response header',
    message: createResponseMessage(0xff, 200, 'Hello: ðŸ˜‚\nworld: \n\n!', {
      'key:name': 'value%:\nname',
    }),
    text:
      's' +
      itos(0xff) +
      ' 200\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
    binary: createBuffer(
      b8(0b1011_1000),
      b16(0xff),
      b16(200),
      '\nkey%3Aname: value%25%3A%0Aname\n\nHello: ðŸ˜‚\nworld: \n\n!',
    ),
  },
  {
    name: 'request empty',
    message: createRequestMessage(0xff, 'echo', void 0),
    text: 'q' + itos(0xff) + ' echo',
    binary: createBuffer(b8(0b1001_1000), b16(0xff), 'echo'),
  },
  {
    name: 'response empty',
    message: createResponseMessage(0xff, 200, void 0),
    text: 's' + itos(0xff) + ' 200',
    binary: createBuffer(b8(0b1011_1000), b16(0xff), b16(200)),
  },
  {
    name: 'close empty',
    message: createCloseMessage(1009, ''),
    text: 'c' + itos(1009),
    binary: createBuffer(b8(0b1100_0000), b16(1009)),
  },
  {
    name: 'follow',
    message: createFollowMessage(0xff, 'hello world!'),
    text: 'f' + itos(0xff) + '\nhello world!',
    binary: createBuffer(b8(0b1101_1000), b16(0xff), 'hello world!'),
  },
];

describe('protocol', () => {
  for (const { name, binary, message, text } of protocolSpecCases) {
    if (text !== null) {
      it(`should parse text ${name}`, () => {
        const parsed = parseText(text);
        expect(parsed).toEqual(message);
      });
    }
    it(`should parse binary ${name}`, () => {
      const parsed = parseBinary(binary);
      if (parsed && 'payload' in parsed && parsed.payload instanceof Buffer) {
        parsed.payload = parsed.payload.toString('utf8');
      }
      expect(parsed).toEqual(message);
    });
    if (text !== null) {
      it(`should stringify text ${name}`, () => {
        expect(stringifyText(message)).toBe(text);
      });
    }
    it(`should stringify binary ${name}`, () => {
      expect(stringifyBinary(message)).toEqual(binary);
    });
  }
});
