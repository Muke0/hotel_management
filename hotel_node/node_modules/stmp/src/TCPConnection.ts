/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-11-29 17:51:35
 */

import net from 'net';
import { debuglog } from 'util';
import {
  Headers,
  HTTP_BAD_REQUEST,
  HTTP_OK,
  HTTP_REQUEST_TIMEOUT,
  STMPMessage,
  WS_PROTOCOL_ERROR,
} from './messages';
import { parseBinary, parseHeaders, stringifyBinary } from './protocol';
import { STMPConnection } from './STMPConnection';
import { STMPServer } from './STMPServer';
import { StreamConsumer } from './StreamConsumer';
import { STMPInstance } from './types';
import { b16, createPrefixedBuffer } from './utils';

const debug = debuglog('stmp:TCPConnection');

const HANDSHAKE_TIMEOUT = createPrefixedBuffer(b16(HTTP_REQUEST_TIMEOUT));
const HANDSHAKE_BAD_REQUEST = createPrefixedBuffer(b16(HTTP_BAD_REQUEST));

export class TCPConnection extends STMPConnection implements STMPInstance {
  private handshakeTimer: any;
  readonly consumer: StreamConsumer;

  constructor(server: STMPServer, socket: net.Socket) {
    super(server, socket);
    this.consumer = new StreamConsumer();
  }

  prepare(handshakeTimeout: number) {
    this.handshakeTimer = setTimeout(
      this.handleHandshakeTimeout,
      handshakeTimeout,
    );
    this.socket.on('data', this.handleHandshakeData);
  }

  private handleHandshakeData = (data: Buffer) => {
    const header = this.consumer.consumeFrame(data);
    if (!header) {
      return;
    }
    debug('handshake frame: %s.', header);
    clearTimeout(this.handshakeTimer);
    this.handshakeTimer = undefined;
    if (header.length < 1) {
      this.socket.end(HANDSHAKE_BAD_REQUEST);
      return;
    }
    const handshake = header.toString();
    const newLine = handshake.indexOf('\n');
    const url = newLine < 0 ? handshake : handshake.substr(0, newLine);
    const headers =
      newLine < 0 ? Headers() : parseHeaders(handshake.substr(newLine + 1));
    this.socket.removeListener('data', this.handleHandshakeData);
    this.init(url, headers);
    this.authenticate().then(() => {
      if (this.handshakeStatus === HTTP_OK) {
        this.socket.on('data', this.handleMessageData);
      }
    });
  };

  private handleMessageData = (data: Buffer) => {
    const frame = this.consumer.consumeFrame(data);
    if (!frame) {
      return;
    }
    let message = parseBinary(frame);
    debug('receive message frame: %s as %s to %O.', data, frame, message);
    if (!message) {
      this.close(WS_PROTOCOL_ERROR);
      return;
    }
    message = this.consumer.mergeMessage(message);
    if (message === null) {
      return;
    }
    this.processMessage(message);
  };

  private handleHandshakeTimeout = () => {
    this.socket.removeAllListeners('data');
    this.socket.end(HANDSHAKE_TIMEOUT);
  };

  send(message: STMPMessage): void {
    const buf = stringifyBinary(message);
    this.socket.write(createPrefixedBuffer(buf));
  }

  protected sendHandshake(status: number, message: string): void {
    this.socket.write(createPrefixedBuffer(b16(status), message));
  }

  protected terminate(): void {
    this.socket.removeAllListeners();
    this.socket.end();
  }
}
